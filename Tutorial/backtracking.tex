\chapter{Exceptions and Backtracking}
In the first section of this chapter we will discuss
\href{https://en.wikipedia.org/wiki/Exception_handling}{\emph{exceptions}} as a means to deal with
error situations.  The second section will introduce a mechanism that supports
\href{https://en.wikipedia.org/wiki/Backtracking}{\emph{backtracking}}.  This mechanism is quite
similar to the exception handling discussed in the first subsection.  Indeed, we will see that the
backtracking mechanism provided in \setlx\ is really just a special case of exception handling.

\section{Exceptions}
If we issue the assignment
\\[0.2cm]
\hspace*{1.3cm}
\texttt{y := x + 1;}
\\[0.2cm]
while the variable \texttt{x} is undefined, \setlx\ reports the following error:
\begin{verbatim}
    Error in "y := x + 1":
    Error in "x + 1":
    'om + 1' is undefined.
\end{verbatim}
Here, evaluation of the expression \texttt{x + 1} has raised an \emph{exception} 
as it is not possible to add a number to the undefined value \texttt{om}.  This exception is then
propagated to the enclosing assignment statement. \setlx\ offers to handle exceptions like the
one described above.  The mechanism is similar to the way exceptions
are treated in 
\href{http://docs.oracle.com/javase/tutorial/essential/exceptions/}{\textsl{Java}} and uses the keywords
``\texttt{try}'' and ``\texttt{catch}''.   If we have a sequence of statements
\textsl{stmntList} and we suspect that 
something might go wrong with these statements, then we can put the list of statements into a
\texttt{try}/\texttt{catch}-block as follows:
\\[0.2cm]
\hspace*{1.3cm}
\texttt{try \{}
\\
\hspace*{1.8cm}
\texttt{\textsl{stmntList}}
\\
\hspace*{1.3cm}
\texttt{\} catch (e) \{ \textsl{errorCode} \}}
\\[0.2cm]
If the execution of \textsl{stmntList} executes without errors, then the
\texttt{try/catch}-block does nothing besides the execution of \textsl{stmntList}.  However, if
one of the statements in \textsl{stmntList} raises an exception \texttt{e}, then the execution of
the statements in \textsl{stmntList} is aborted and instead the statements in \textsl{errorCode} are
executed.  These statements can use the variable \texttt{e} that contains the exception that has
been raised.


Typically, exception handling is necessary when  processing user input.  Consider the program
shown in Figure \ref{fig:bisection-exception.stlx} on page \pageref{fig:bisection-exception.stlx}.
The function \texttt{findZero} implements 
the \href{https://en.wikipedia.org/wiki/Bisection_method}{bisection method} which can be used to
find a zero of a function that has a sign change in a given interval.  The first argument of 
\texttt{findZero} is a function $f$, while the arguments $a$ and $b$ are the left and right
boundary of the interval where the zero of $f$ is sought.  Therefore, $a$ has to be less than
$b$.  Finally, for the bisection algorithm implemented in the function \texttt{findZero} to
work, the function $f$ needs to have a sign change in the interval $[a,b]$, i.e.~the sign of $f(a)$
needs to be different from the sign of $f(b)$.  

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    findZero := procedure() {
        try {
            s := read("Please enter a function: ");
            f := eval("x |-> " + s);
            a := read("Enter left  boundary: ");
            b := read("Enter right boundary: ");
            z := bisection(f, a, b);
            print("zero at z = $z$");
        } catch (e) {
            print(e);
            print("Please try again.\n");
            findZero();
        }
    };
    bisection := procedure(f, a, b) {
        if (a > b) {
            throw("Left boundary a has to be less than right boundary b!");   
        }
        [ fa, fb ] := [ f(a), f(b) ]; 
        if (fa * fb > 0) {
            throw("Function f has to have a sign change in [a, b]!");
        }
        while (b - a >= 10 ** -12) {
            c := 1/2 * (a + b);
            fc := f(c); 
            if ((fa < 0 && fc < 0.0) || (fa >= 0 && fc >= 0)) {
                a := c; fa := fc; 
            } else {
                b := c; fb := fc; 
            }
        }
        return 1/2 * (a + b);
    };
\end{Verbatim}
\vspace*{-0.3cm}
\caption{The bisection method for finding a zero of a function.}
\label{fig:bisection-exception.stlx}
\end{figure}

The function \texttt{findZero} asks the user to input the function $f$ together with the left and
right boundary of the interval $[a,b]$.  The idea is that the user inputs a term describing the
function value of $f$ for a given value of $x$.  For example, in order to compute the zero of the
function
\\[0.2cm]
\hspace*{1.3cm}
$x \mapsto x*x - 2$
\\[0.2cm]
the user has to provide the string ``\texttt{x*x-2}'' as input when prompted by the function \texttt{read} in
line 3.  The string \texttt{s} that is input by the user is then converted into the string
\\[0.2cm]
\hspace*{1.3cm}
\texttt{x |-> x*x-2}
\\[0.2cm]
in line 4 and the resulting string is then evaluated.  In this way, the
variable \texttt{f} in line 4 will be assigned the function mapping \texttt{x} to \texttt{x*x-2}
just as if the user had written
\\[0.2cm]
\hspace*{1.3cm}
\texttt{f := x |-> x*x-2;}
\\[0.2cm]
in the command line.

 
There are a couple of things that can go wrong with the function \texttt{findZero}.  First,
the string \texttt{s} that is input by the user might not be a proper function and then
we would presumably get a parse error in line 4.  In this case, the function \texttt{parse}
invoked in line 4 will raise an exception. Next, if the user enters a string of the form
\\[0.2cm]
\hspace*{1.3cm}
\texttt{x ** y}
\\[0.2cm]
then, since the variable \texttt{y} is undefined, the evaluation of the function would
raise an exception when \setlx\ tries to evaluate an expression of the form
\\[0.2cm]
\hspace*{1.3cm}
\texttt{x ** om}.
\\[0.2cm]
Furthermore, either of the two conditions
\\[0.2cm]
\hspace*{1.3cm}
$a < b$ \quad or \quad $f(a) * f(b) \leq 0$
\\[0.2cm]
might be violated.  In this case, we raise an exception in line 17 or
line 21 of the function \texttt{bisection}.  This is done using the function \texttt{throw}.
Since we don't want to abort the program on the occurrence of an exception, the whole block of
code from line 3 up to line 8 is enclosed in a \texttt{try}/\texttt{catch}-block.  In case there is
an exception, the value of this exception, which is a string containing an error message, is
caught in the variable \texttt{e} in line 9.  To continue our program, we print the error message
in line 10 and then invoke the function \texttt{findZero} recursively so that the user of
the program gets another chance to enter valid input.

\subsection{Different Kinds of Exceptions}
\setlx\ supports two different kinds of exceptions:
\begin{enumerate}
\item \emph{User generated} exceptions are generated by the user via a \texttt{throw} statement.
      In general, the statement
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{throw($e$)}
      \\[0.2cm]
      raises a \emph{user generated} exception with the value $e$.  Here, $e$ can be any value.
      However, typically $e$ will be a string.
\item \emph{Language generated} exceptions are the result of error conditions arising in
      the program. 
\end{enumerate}
While all kinds of exceptions can be caught with a \texttt{catch} clause, most of the time
it is useful to distinguish between the different kinds of exceptions.  This is supported
by offering two variants of \texttt{catch}:
\begin{enumerate}
\item \texttt{catchUsr} only catches user generated exceptions.  For example, the statement
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{try \{ throw(1); \} catchUsr(e) \{ print(e); \}}
      \\[0.2cm]
      prints the number 1, but assuming that the variable \texttt{y} is undefined, the 
      statement 
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{try \{ x := y + 1; \} catchUsr(e) \{ print("caught " + e); \}}
      \\[0.2cm]
      will not print anything but instead this command raises an exception.
\item \texttt{catchLng} only catches language generated exceptions.  Therefore, the statement
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{try \{ x := y + 1; \} catchLng(e) \{ print("caught " + e); \}}
      \\[0.2cm]
      prints the text
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{caught Error: 'om + 1' is undefined.}
      \\[0.2cm]
      On the other hand,  the exception thrown in the statement
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{try \{ throw(1); \} catchLng(e) \{ print(e); \}}
      \\[0.2cm]
      is a user generated exception that is not caught by \texttt{catchLng}.  Instead, the exception
      is propagated outside of this statement.  Hence, the net effect of this statement is to raise
      an exception.
\end{enumerate}
Being able to distinguish between user generated  and language generated exceptions is
quite valuable and we strongly advocate that user generated exceptions should only be
catched using a \texttt{catchUsr} clause.  The reason is, that a simple
\texttt{catch} clause which the user intends to catch a user generated exceptions might,
in fact, catch 
other exceptions and thus mask real errors.  In general, the \setlx\ interpreter
implements a \emph{fail fast} strategy:  Once an error is discovered, the execution of the
program is aborted.  The interpreter does a lot of effort to detect errors as early as
possible.  However, this strategy  is thwarted if unrestricted \texttt{catch} clauses are used,
because then language generated exceptions are effectively silenced.  As a result, programming
mistakes might go undetected and result in bugs that are very difficult to locate.

\section{Backtracking}
One of the distinguishing features of the programming language 
\href{http://en.wikipedia.org/wiki/Prolog}{\textsl{Prolog}}
is the fact that \textsl{Prolog} supports 
\href{http://en.wikipedia.org/wiki/Backtracking}{\emph{backtracking}}.  
However, on closer inspection of the programs found in popular text books, e.g.~``\emph{The Art of Prolog}''
\cite{sterling86} and ``\emph{Prolog Programming for Artificial Intelligence}'' \cite{bratko:90}, it
becomes obvious that very few programs actually make use of 
backtracking in its most general form.   The first author of this tutorial has developed
\textsl{Prolog} based software in an industrial environment for more than 10 years.  His personal
experience suggests that \textsl{Prolog} programs that use backtracking in an unrestricted fashion
tend to be very hard to maintain.   
Therefore, it is our believe that the use of backtracking should follow the
\emph{generate and test} paradigm:
\begin{enumerate}
\item Assume our goal is to find some $x$ such that $x$ is the solution of a given problem.
\item In order to find possible values for $x$, we invoke a \emph{generating function} that provides
      us with \emph{solution candidates}, i.e. the generating function produces values of $x$ that
      might possibly be solutions to the given problem.  However, the set of values produced by the generating
      function is only a superset of the set of solutions, i.e.~some of those values do not actually
      solve the given problem.  Although it is perfectly acceptable that most of the values generated do not solve
      the problem, it is required that the generating function will never miss a solution.
\item In order to check which of the generated values are indeed solutions, these values
      have to be \emph{tested}.  If a test fails for a given value $x$, the program backtracks to
      step 2 where the next value to be tested is generated. 
\end{enumerate}
In order to support the generate and test paradigm,  \setlx\ 
implements backtracking only in a very restricted form.  Thus, we avoid the
pitfalls that accompany an unrestricted use of backtracking.
Backtracking is implemented  via the keywords ``\texttt{check}'' and
``\texttt{backtrack}''.  A block of the form
\\[0.2cm]
\hspace*{1.3cm}
\texttt{check \{} 
\\
\hspace*{1.8cm}
\textsl{stmntList}
\\
\hspace*{1.3cm}
\texttt{\}}
\\[0.2cm]
is more or less\footnote{
Technically, instead of the string \texttt{\symbol{34}fail\symbol{34}}, \setlx\ 
generates a unique exception, which is referred to as a \emph{fail-exception}.
This exception can only be catched using \texttt{check}. 
}
converted into a block of the following form:
\\[0.2cm]
\hspace*{1.3cm}
\texttt{try \{} 
\\
\hspace*{1.8cm}
\textsl{stmntList}
\\
\hspace*{1.3cm}
\texttt{\} catch ($e$) \{}
\\
\hspace*{1.8cm}
\texttt{if ($e$ != \symbol{34}fail\symbol{34}) \{ throw($e$); \}}
\\
\hspace*{1.3cm}
\texttt{\}}
\\[0.2cm]
Here, \textsl{stmntList}  might contain the keyword ``\texttt{backtrack}''.  This keyword is
translated into the command \texttt{throw(\symbol{34}fail\symbol{34})}.   

In the rest of this section we show how to solve two classical logical puzzles using backtracking.
As a first example,  we solve the 8 queens puzzle.  We will see that this puzzle can be solved using
a straightforward recursive approach.  The second example is the zebra puzzle.  In order to solve
this puzzle succinctly, we need to make use of \emph{higher-order programming}, i.e.~we solve the
problem by writing a function that, instead of solving the problem directly, will first generate
some \setlx\ code.  This code is then executed and thereby the problem is solved.  Hence, the zebra
puzzle provides the opportunity to show of the power of the \texttt{eval} function provided by \setlx.

\subsection{The 8 Queens Puzzle}
The program in Figure \ref{fig:queens-nice.stlx} on page
\pageref{fig:queens-nice.stlx} solves the 
\href{http://en.wikipedia.org/wiki/Eight_queens_puzzle}{\emph{8 queens puzzle}}.  This problem asks to
position 8 queens on a chessboard such that no queen can attack another queen.  In chess, a queen
can attack all those positions that are either on the same row, on the same column, or on the
same diagonal as the queen.  The details of the program in Figure \ref{fig:queens-nice.stlx}
are as follows.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    solve := procedure(queens, n) { 
        if (#queens == n) {
            return queens;
        }
        for (x in {1..n} - {i : i in queens}) {
            check {
                testNext(queens, x);
                return solve(queens + [x], n);
            } 
        }
        backtrack;
    };
    testNext := procedure(queens, x) {
        m := #queens;
        if (exists (i in {1..m} | i-queens[i] == m+1-x || i+queens[i] == m+1+x)) {
            backtrack;
        }
    };
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Solving the 8 queens puzzle using \texttt{check} and \texttt{backtrack}.}
\label{fig:queens-nice.stlx}
\end{figure}
\begin{enumerate}
\item The procedure \texttt{solve} has two parameters.
      \begin{enumerate}
      \item The first parameter \texttt{queens} is a list of positions of queens that
            have already been placed on the board.  It can be
            assumed that the queens already positioned in \texttt{queens} 
            do not attack each other.
            
            Technically, \texttt{queens} is a list of integers.
            If \texttt{queens[$i$]$=k$}, then the queen in row $i$ is placed in column $k$.  For example,
            \\[0.2cm]
            \hspace*{1.3cm}
            $\texttt{queens} = \texttt{[4, 8, 1, 3, 6, 2, 7, 5]}$
            \\[0.2cm]
            is a solution of the 8 queens puzzle.  This solution is depicted in Figure
            \ref{fig:queens-solution} on page \pageref{fig:queens-solution}.

            \begin{figure}[!ht]
              \centering
              \hspace*{0.0cm}
              \vbox{\offinterlineskip
                \hrule height1pt
                \hbox{\vrule width1pt\bigchess
                  \vbox{\hbox{0Z0L0Z0Z}
                    \hbox{Z0Z0Z0ZQ}
                    \hbox{QZ0Z0Z0Z}
                    \hbox{Z0L0Z0Z0}
                    \hbox{0Z0Z0L0Z}
                    \hbox{ZQZ0Z0Z0}
                    \hbox{0Z0Z0ZQZ}
                    \hbox{Z0Z0L0Z0}}%
                  \vrule width1pt}
                \hrule height1pt}

              \caption{A solution of the 8 queens puzzle.}
              \label{fig:queens-solution}
            \end{figure}

 
      \item The second parameter \texttt{n} is the size of the board.  
      \end{enumerate}
      In order to solve the 8 queens puzzle, the procedure \texttt{solve} can be called as 
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{solve([], 8)}.
      \\[0.2cm]
      Taking the parameter \texttt{queens} to be the empty list assumes that initially no queen has
      been placed on the chess board.  Therefore, the assumption that the queens already
      positioned in the list \texttt{queens} do not attack each other is trivially satisfied.
\item In line 2 it is checked, whether the list \texttt{queens} already specifies the positions of
      \texttt{n} queens, that is we check whether \texttt{queens} is  a list of length \texttt{n}.
      If this is the case, then because of the assumption that the queens 
      specified in \texttt{queens} do not attack each other, the problem is solved and therefore the list
      \texttt{queens} is a solution that is returned.
\item Otherwise, we  find a position \texttt{x} for the next queen in line 5.  Of course,
      there is no point in trying to position the next queen into a column that has already been
      taken by one of the queens in the list \texttt{queens}.  Therefore, the number of column positions
      available for the next queen is given by the set
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{\{1 ..  $\hspace*{-0.2cm}$n\} - \{i $\hspace*{-0.1cm}$: $\hspace*{-0.2cm}$i in queens\}}.
      \\[0.2cm]
      Note that we had to convert the list \texttt{queens} into the set 
      \texttt{\{i $\hspace*{-0.1cm}$: $\hspace*{-0.2cm}$i in queens\}}
      in order to be able to subtract the set of columns specified in \texttt{queens} from the set of all
      possible columns.
\item Once we have decided to position the next queen in column \texttt{x}, we have to 
      test whether a queen that is put into that position can be attacked by another queen
      which happens to be on the same diagonal.  This test is performed in line 7 with the help
      of the function \texttt{testNext}.
\item If this test succeeds, we add a queen in position \texttt{x} to the list \texttt{queens} and
      recursively try to solve the resulting instance of the problem.
\item On the other hand, if the call to \texttt{testNext} in line 7 fails, we have to try
      the remaining values for \texttt{x}.   The function \texttt{testNext} does not return a 
      Boolean value to indicate success or failure so at this point you might well
      ask how we know that the call to \texttt{testNext} has failed.  The answer is that the function
      \texttt{testNext} includes a call to \texttt{backtrack} if it is not possible to
      place the next queen in column \texttt{x}.  Technically, calling \texttt{backtrack}
      raises an exception that is caught by the \texttt{check} statement in line 6.
      After that,  the \texttt{for} loop in line 5 proceeds and picks the next
      candidate for \texttt{x}.
\item During the recursive invocation of the procedure \texttt{solve} in line 8, we might
      discover that the list \texttt{queens + [x]} can not be completed into a solution of the 8
      queens puzzle.   In this case, it is the function \texttt{solve} that backtracks
      in line 11.  This happens when the \texttt{for} loop in line 5 is exhausted and we
      have not found a solution.  Then
      control  reaches line 11, where the backtrack statement  signals that the list \texttt{l}
      could not be completed into a solution to the \texttt{n} queens puzzle.
\item The function \texttt{testNext} in line 13 has two parameters:  The first parameter is the list
      of already positioned queens while the second parameter specifies the column of the next
      queen.  The function checks whether the queen specified by \texttt{x} is on the same
      diagonal as any of the queens in \texttt{queens}.
      
      In order to understand the calculation in line 15 we have to realize that the
      Cartesian coordinates of the queens in column \texttt{x} are 
      \\[0.2cm]
      \hspace*{1.3cm}
      $\pair(\texttt{\#queens}+1, \mathtt{x})$.
      \\[0.2cm]
      A diagonal is specified as the equation of a line with slope either $+1$ or $-1$.
      The $i$-th  queen in \texttt{queens} has the coordinates
      \\[0.2cm]
      \hspace*{1.3cm}
      $\pair(\texttt{i}, \mathtt{queens[i]})$.      
      \\[0.2cm]
      Therefore, it is on the same ascending diagonal as the queen specified by \texttt{x} if
      we have
      \\[0.2cm]
      \hspace*{1.3cm}
      $\texttt{i-queens[i]} = \texttt{\#queens+1-x}$,
      \\[0.2cm]
      while it is one the same descending diagonal if we have.
      \\[0.2cm]
      \hspace*{1.3cm}
      $\texttt{i+queens[i]} = \texttt{\#queens+1+x}$.
\end{enumerate}

It is easy to change the program in Figure \ref{fig:queens-nice.stlx} such that all
solutions are completed.   Figure \ref{fig:queens-all.stlx} on page
\pageref{fig:queens-all.stlx} shows how this is done.
\begin{enumerate}
\item We have added a function \texttt{allSolutions}.  This function gets the parameter
      \texttt{n}, which is the size of the board.
      The function returns the set of all solutions of the $n$ queens puzzle.
      To do so, it first initializes the variable \texttt{all} to the empty set.
      The solutions are then collected in this set.
\item The new version of the function \texttt{solve} gets \texttt{all} as an additional parameter.
      Note that this parameter is specified in line 2 as an \texttt{rw} parameter, so 
      the value of \texttt{all} can actually be changed by the procedure \texttt{solve}.
\item The important change in the implementation of \texttt{solve} is that instead of
      returning a solution,  a newly found solution is added to the set \texttt{all} in
      line 10. After that, the function \texttt{solve} backtracks to look for more
      solutions.   Since the function \texttt{solve} is recursive, this backtracking asks the
      \texttt{for}-loop in line 13 to look for another solution.
\item Note that we have to enclose the call to \texttt{solve} in line 4 in a \texttt{check}
      statement.  The reason is that the function \texttt{solve} will never return anything.
      Instead, it will continue to add solutions to the set \texttt{all}.   If this is no longer
      possible, the call to \texttt{solve} will backtrack in line 19.  The \texttt{check} statement 
      in the procedure \texttt{allSolutions} is meant to catch the corresponding fail-exception.
\item The implementation of the function \texttt{testNext} has not changed from the previous program.
\end{enumerate}
This program finds all 92 solutions of the $8$ queens puzzle.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    allSolutions := procedure(n) {
        all := {};
        check {
            solve([], n, all);
        }
        return all;
    };
    solve := procedure(queens, n, rw all) { 
        if (#queens == n) {
            all += { queens };
            backtrack;
        }
        for (x in {1 .. n} - {i : i in queens}) {
            check {
                testNext(queens, x);
                solve(queens + [x], n, all);
            } 
        }
        backtrack;
    };
 \end{Verbatim}
\vspace*{-0.3cm}
\caption{Computing all solutions of the $n$ queens puzzle.}
\label{fig:queens-all.stlx}
\end{figure}
\vspace*{0.3cm}

The keyword \texttt{check} can be used with an additional optional branch.  In this case the
complete \texttt{check} block has the form
\\[0.2cm]
\hspace*{1.3cm}
\texttt{check \{} 
\\
\hspace*{1.8cm}
\textsl{stmntList}
\\
\hspace*{1.3cm}
\texttt{\} afterBacktrack \{ \textsl{body} \}}
\\[0.2cm]
Here, \textsl{body} is a list of statements that is executed if there is a call to \texttt{backtrack} in
\textsl{stmntList}.  For example, the code
\begin{verbatim}
    check { 
        print(1); 
        backtrack; 
        print(2); 
    } afterBacktrack { 
        print(3); 
    }
\end{verbatim}
prints the number 1 and 3.

\subsection{The Zebra Puzzle}
There are many different versions of the
\href{https://en.wikipedia.org/wiki/Zebra_Puzzle}{\emph{zebra puzzle}}.  The version below is taken
from \href{https://en.wikipedia.org/wiki/Zebra_Puzzle}{\emph{Wikipedia}}.  The puzzle is the following:
\begin{enumerate}
\item There are five houses.
\item The Englishman lives in the red house.
\item The Spaniard owns the dog.
\item Coffee is drunk in the green house.
\item The Ukrainian drinks tea.
\item The green house is immediately to the right of the ivory house.
\item The Old Gold smoker owns snails.
\item Kools are smoked in the yellow house.
\item Milk is drunk in the middle house.
\item The Norwegian lives in the first house.
\item The man who smokes Chesterfields lives in the house next to the man with the fox.
\item Kools are smoked in the house next to the house where the horse is kept.
\item The Lucky Strike smoker drinks orange juice.
\item The Japanese smokes Parliaments.
\item The Norwegian lives next to the blue house.
\item Who drinks water? 
\item Who owns the zebra?
\end{enumerate}
In order to solve the puzzle, we also have to know the following facts:
\begin{enumerate}
\item Each of the five houses is painted in a different color.
\item The inhabitants of the five houses are of different nationalities,
\item they own different pets, 
\item they drink different beverages, and 
\item they smoke different brands of cigarettes. 
\end{enumerate}

In order to solve this problem we use a generic approach and first implement a general function that
can be used to solve
\href{https://en.wikipedia.org/wiki/Constraint_satisfaction_problem}{\emph{constraint satisfaction problems}}.  
Figure \ref{fig:generateAndTest.stlx} 
on page \pageref{fig:generateAndTest.stlx} shows the implementation of the function
\texttt{generateAndTest} that can be used to solve a constraint satisfaction problem via
backtracking.  This function is called with three arguments.
\begin{enumerate}
\item The first argument \texttt{constraints} is a list of constraints.  Each of the elements in
      this list are, in turn,  lists of either two or three items.  These lists have the form
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{[var, assign, condition]},
      \\[0.2cm]
      where the last item \texttt{condition} may be missing.  These items have the following
      interpretation.
      \begin{enumerate}
      \item \texttt{var} is a string that is interpreted as the name of a variable.
      \item \texttt{assign} is a string that can be interpreted as a \setlx\ statement.  Typically,
            this will be an assignment statement.  Another common case will the statement
            ``\texttt{skip}'' that does nothing.
      \item \texttt{condition} is a string that can be parsed as a logical expression in \setlx.
            If the condition is missing it is implicitly interpreted as the trivial condition \texttt{true}.
      \end{enumerate}
      For example, the constraint ``\textsl{The Englishman lives in the red house.}'' can be
      modeled by the constraint
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{[\symbol{34}english\symbol{34}, \symbol{34}red := english\symbol{34}, true]}.
      \\[0.2cm]
      This constraint introduces the two variables ``\texttt{english}'' and ``\texttt{red}''.
      Due to the assignment 
      \\[0.2cm]
      \hspace*{1.3cm}
      ``\texttt{red := english}'', 
      \\[0.2cm]
      these two variables are required to have
      the same value. Since there are no further constraints, the condition has the value
      \texttt{true}.  Hence, we could also have dropped this part of the constraint and thereby
      shorten it to
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{[\symbol{34}english\symbol{34}, \symbol{34}red := english\symbol{34}]}.
\item \texttt{values} is a list of the possible values for those variables that are introduced via
      the first argument \texttt{constraints}.
\item \texttt{result} is a string that, when evaluated as an expression, returns the solution of the
      constraint satisfaction problem.
\end{enumerate}

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    generateAndTest := procedure(constraints, values, result) {
        stmnt := "procedure() {";
        n     := #constraints;
        for (i in [1..n]) {
            if (#constraints[i] == 3) {
                [var, assign, condition] := constraints[i];
            } else {
                [var, assign] := constraints[i];
                condition := true;
            }
            stmnt += "for ($var$ in $values$) {";
            if (assign != "skip") {
                stmnt += assign + ";";
            }
            stmnt += "check {";
            if (condition != true) {
                stmnt += "if (!($condition$)) { backtrack; }";
            }
        }
        stmnt += "return $result$;";
        stmnt += "}" * (2*n+1);
        return eval(stmnt+"()");
    };
\end{Verbatim}
\vspace*{-0.3cm}
\caption{The function \texttt{generateAndTest}.}
\label{fig:generateAndTest.stlx}
\end{figure}

It is easiest to understand how  the arguments of \texttt{generateAndTest} are used by inspecting
an example.  Suppose we are looking for natural numbers $a,b,c \in \{1, \cdots, 5\}$ such that both
\\[0.2cm]
\hspace*{1.3cm}
$b = a + 1$ \quad and \quad $a^2 + b^2 = c^2$
\\[0.2cm]
holds.  Then we can define the parameters of the function \texttt{generateAndTest} as follows:
\begin{enumerate}
\item \texttt{constraints := [ ["a", "b := a + 1", "b <= 5"],} \\
      \hspace*{3.0cm}
      \texttt{["c", "skip", "a**2 + b**2 == c**2"] ];}
\item \texttt{values := \{1..5\};}
\item \texttt{result := "[a, b, c]";}
\end{enumerate}
Calling \texttt{generateAndTest} with these arguments will return the value \texttt{[3,4,5]}.  It is
easy to check that the assignments $a := 3$, $b := 4$, and $c := 5$ solve the given problem.

In order to understand the mechanics of \texttt{generateAndTest} we have to know that this function
works in two steps.  
\begin{enumerate}
\item In the first step, the function generates a string that can be parsed and
      evaluated as a \setlx\ procedure.  This string is called \texttt{stmnt} in Figure
      \ref{fig:generateAndTest.stlx} on page \pageref{fig:generateAndTest.stlx}.   Figure
      \ref{fig:generateAndTest.stlx-code} on page \pageref{fig:generateAndTest.stlx-code}. shows how this
      string looks for the example discussed above.   From the example we can see that every constraint is
      translated into a \texttt{for} loop.  This for loop iterates over all elements of the argument
      \texttt{values}.  Inside this loop we first have the assignment \texttt{assign}, which is then followed by the
      \texttt{condition}.  Note, however, that this condition is encapsulated in a \texttt{check}
      statement.  If the \texttt{condition} is not satisfies, we have to \texttt{backtrack} so that the
      for loop can try the next value for the given variable.  We can also see that the second contsraint
      is nested in the first constraint.
\item In the second step, the generated procedure is evaluated.  This happens through the call of
      the function \texttt{eval} in line 22 of Figure \ref{fig:generateAndTest.stlx}.
\end{enumerate}
The kind of programming that is exhibited here is often called 
\href{https://en.wikipedia.org/wiki/Higher-order_programming}{\emph{higher-order programming}}.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    procedure() {
      for (a in [1, 2, 3, 4, 5]) {
        b := a + 1;
        check {
          if (!(b <= 5)) { backtrack; }
          for (c in [1, 2, 3, 4, 5]) {
            check {
              if (!(a**2 + b**2 == c**2)) { backtrack; }
              return [a,b,c];
            }
          }
        }
      }
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{The statement generated by \texttt{generateAndTest}.}
\label{fig:generateAndTest.stlx-code}
\end{figure}
\noindent
We proceed to discuss the details of the generation of the string \texttt{stmnt} that is later
evaluated.  
\begin{enumerate}
\item The string \texttt{stmnt} that is to contain the definition of the generated code is
      created in line 2.
\item In line 3 we define \texttt{n} to be the number of elements of the list \texttt{constraints}.
\item Therefore, the \texttt{for} loop in line 4 effectively iterates over all constraints in the
      list \texttt{constraints}.
\item Since there maybe constraints where the \texttt{condition} is missing, the \texttt{if}
      statement in line 5 checks whether the $i$th constraint is a list of two or three elements.
      Then, the variables \texttt{var}, \texttt{assign}, and
      \texttt{condition} are set to the first, second, and third element of the $i$th constraint.
      In case there are only two elements, the variable \texttt{condition} is set to the trivial
      test \texttt{true}.
\item Next, we generate the \texttt{for} loop that tries the different elements of \texttt{values}
      for the variable \texttt{var} of the $i$th constraint.
\item If there is are real assignment, i.e.~if \texttt{assign} is different from the string
      ``\texttt{skip}'', this assignment is the first statement in the \texttt{for} loop that is generated.
\item Finally, if the test \texttt{condition} is non-trivial, an \texttt{if} statement is added that
      checks if \texttt{condition} is satisfies and that backtracks if the condition is violated.
\item Since the generated procedure takes no arguments, we can evaluate it by appending the string
      ``\texttt{()}'' to the string \texttt{stmnt} and then calling the function \texttt{eval} on
      the resulting string.
\end{enumerate}

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    nextTo   := procedure(a, b)          { return b == a+1 || a == b+1;  };
    distinct := procedure(a, b, c, d, e) { return #{a, b, c, d, e} == 5; };
    values := [1..5];   // 1. There are five houses
    constr := 
    [ //  2. The Englishman lives in the red house.
      ["english", "red := english"],
      //  3. The Spaniard owns the dog.
      ["spaniard", "dog := spaniard"],
      //  4. Coffee is drunk in the green house.
      ["coffee", "green := coffee"],
      //  5. The Ukrainian drinks tea.
      ["ukrainian", "tea := ukrainian"],
      //  6. The green house is immediately to the right of the ivory house.
      ["ivory", "skip", "green == ivory + 1"],
      //  7. The Old Gold smoker owns snails.
      ["oldGold", "snails := oldGold"],
      //  8. Kools are smoked in the yellow house.
      ["kools", "yellow := kools"],
      //  9. Milk is drunk in the middle house.
      ["milk", "skip", "milk == 3"],
      // 10. The Norwegian lives in the first house.
      ["norwegian", "skip", "norwegian == 1"],
      // 11. Chesterfields are smoked next to the fox.
      ["chesterfields", "skip"],
      ["fox", "skip", "nextTo(chesterfields, fox)"],
      // 12. Kools are smoked in the house next to the horse.
      ["horse", "skip", "nextTo(horse, kools)"],
      ["zebra", "skip", "distinct(fox, horse, snails, dog, zebra)"],
      // 13. The Lucky Strike smoker drinks orange juice.
      ["luckies", "orange := luckies"],
      ["water", "skip", "distinct(water, tea, milk, orange, coffee)"],
      // 14. The Japanese smokes Parliaments.
      ["japanese", "parliaments := japanese",
       "distinct(norwegian, ukrainian, english, spaniard, japanese) && 
        distinct(kools, chesterfields, oldGold, luckies, parliaments)"],
      // 15. The Norwegian lives next to the blue house
      ["blue", "skip",
       "nextTo(norwegian, blue) && distinct(yellow, blue, red, ivory, green)"],
      // 16. Who drinks water?
      ["water", "skip", "distinct(water, tea, milk, orange, coffee)"],
      // 17. Who owns the zebra?
      ["zebra", "skip", "distinct(fox, horse, snails, dog, zebra)"]
    ];
    result := "[zebra, water]";
    [zebra, water] := generateAndTest(constr, values, result);
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Coding the zebra problem.}
\label{fig:zebra.stlx}
\end{figure}

Finally, we are ready to solve the zebra puzzle.  Figure \ref{fig:zebra.stlx} on page
\pageref{fig:zebra.stlx} shows how to set the parameters of the function \texttt{generateAndTest}
to solve the zebra puzzle.  The idea is to model the colors of the houses, the nationalities of
their inhabitants, the beverages, the cigarette brand, and the pets by numbers from the set
$\{1,2,3,4,5\}$.  For example, if the variable ``\texttt{red}�� has the value 3, then this is
interpreted as the fact that the third house is red.  Let us discuss the details of this program line by line.
\begin{enumerate}
\item In line 1 we define the auxiliary function \texttt{nextTo}.  This function checks whether
      the houses given to it as arguments are next to each other.  Now $a$ is next to $b$ if either
      $a$ is immediately to the left of $b$ or if $a$ is immediately to the right of $b$.  In the
      first case we have that $b = a + 1$, in the second case we have $a = b + 1$.
\item The function \texttt{distinct}, which is given in line 2 checks whether the five
      arguments given to it are all distinct.  This is the case if and only if the set
      $\{a,b,c,d,e\}$ contains exactly five elements.
\item Since we model the houses by the number from 1 to 5, the set of possible values for all
      variables occurring in the zebra puzzle is the set $\{1,2,3,4,5\}$.  This explains line 3.
\item Next, the different statements of the zebra puzzle are translated into a list of constraints.
      For example, the constraint that the Englishman lives in the red house is translated into the list
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{["english", "red := english"]}
      \\[0.2cm]
      This constraint introduces the variable ``\texttt{english}'' and furthermore guarantees that the
      variable ``\texttt{red}'' has the same value as the variable ``\texttt{english}''. 

      As another example, let us explore how the statement 
      \\[0.2cm]
      \hspace*{1.3cm}
      ``\textsl{Kools are smoked in the house next to the house where the horse is kept.}'' 
      \\[0.2cm]
      is translated into a constraint in line 26.  Since the variable ``\texttt{kools}'' has already
      been introduced in line 18, we only need to introduce the variable ``\texttt{horse}'' to model
      this statement.  The fact that the horse is in the house next to the house where Kools are
      smoked is specified via the condition
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{nextTo(horse, kools)}.
\item Some of the constraints have a condition that uses the function \texttt{distinct}.  Let us
      explore the use of this function for the nationalities.  Line 33 introduces the
      variable ``\texttt{japanese}''.  Since this is the last variable that introduces a nationality,
      we can now evaluate the condition that the nationalities are all different via
      the use of the function \texttt{distinct}.  Since the constraint in line 33 also introduces
      the variable ``\texttt{parliaments}'', which is the last of the cigarette brands, we also have
      attached the condition that all cigarette brands are different,
      
      The general idea is to attach a condition as soon as all variables mentioned in this condition
      have been introduced and hence are defined.  As another example, line 40 introduces the
      variable ``\texttt{water}''.  Since this is the last of the beverages, the condition
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{"distinct(water, tea, milk, orange, coffee)"}
      \\[0.2cm]
      is attached to the constraint introducing the variable ``\texttt{water}''.
\item Since we are only interested in the house where the zebra lives and the house where the
      inhabitant drinks water, the variable result is defined as the string
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{\symbol{34}[zebra, water]\symbol{34}}
      \\[0.2cm]
      in line 44.
\item Finally, line 45 calls the function \texttt{generateAndTest} to solve the puzzle.
\end{enumerate}
When the program runs we find out that the zebra is in house number 5 while the inhabitant of the
first house drinks water.


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "tutorial"
%%% End: 
