\chapter{Predefined Functions}
This chapter lists  the predefined functions.  The chapter is divided into eight
sections.
\begin{enumerate}
\item The first section lists all functions that are related to sets and lists.
\item The second section lists all functions that are related to strings.
\item The third sections lists all functions that are used to work with terms.
\item The following sections lists all mathematical functions, e.g.~functions 
      like \texttt{sqrt} or \texttt{exp}.
\item The next section list all functions that are used to test whether an object has a
      given type.
\item Section six lists the functions that support interactive debugging.
\item Section seven discusses the functions related to I/O.
\item Section eight discusses the plotting functions.
\item The last sections lists all those procedures that did not fit in 
      any of the previous sections.  
\end{enumerate}

\section{Functions and Operators on Sets and Lists}
Most of the operators and functions that are supported on sets and lists have already been
discussed.  For the convenience of the reader, this section describes all
operators and functions, even those that have already been discussed.  
\begin{enumerate}
\item \texttt{+}:  For sets, the binary operator ``\texttt{+}'' computes the union
      of its arguments.  For lists, this operator appends its arguments.

      If the first argument of the binary operator ``\texttt{+}'' is a set and the second argument
      is a list, then the elements of the list are added to the set.  If, instead, the first
      argument is a list and the second argument is a set, then the set is converted into a list and
      this list is appended to the first list.

      This makes it trivial to implement a sorting procedure as shown below:
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{mySort := l |-> [] + (\{\} + l);}
      \\[0.2cm]
      When the function \texttt{mySort} is called with a list \texttt{l}, the following happens:
      \begin{enumerate}
      \item The elements of the list \texttt{l} are inserted into a set.  
      \item The elements of this set, which is ordered since all sets are ordered in \setlx, are
            inserted into a list.
      \end{enumerate}
\item \texttt{*}:  If both arguments are sets, the operator ``\texttt{*}'' computes the
      intersection of its arguments. 
      
      If one argument is a list $l$ and the other argument is a number $n$, then the list
      $l$ is appended to itself $n$ times.  Therefore, the expression
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{[1, 2, 3] * 3}
      \\[0.2cm]
      yields the list
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{[1, 2, 3, 1, 2, 3, 1, 2, 3]}
      \\[0.2cm]
      as a result.  Instead of being a list, the argument $l$ can also be a string.
      In this case, the string $l$ is replicated $n$ times.
\item \texttt{-}:  The operator ``\texttt{-}'' computes the set difference of its arguments.
      This operator is only defined for sets.
\item \texttt{\symbol{37}}:  The operator ``\texttt{\symbol{37}}'' computes the 
      \href{https://en.wikipedia.org/wiki/Symmetric_difference}{\emph{symmetric difference}} of its arguments.
      This operator is not defined for lists.

      Of course, all of the operators discussed so far are also defined on numbers and
      have the obvious meaning when applied to numbers.
\item \texttt{**}: The operator ``\texttt{**}'' computes the 
      \href{https://en.wikipedia.org/wiki/Power_set}{power set} of the set $s$ if it is used
      in an expression of the form
      \\
      \hspace*{1.3cm}
      \texttt{2 ** $s$}.
      \\[0.2cm]
      If, instead, the operator is used in an expression of the form
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{s ** 2}
      \\[0.2cm]
      where $s$ is a set, then it returns the 
      \href{https://en.wikipedia.org/wiki/Cartesian_product}{Cartesian product} of $s$ with itself.

      The operator ``\texttt{**}'' is not defined for lists.
\item \texttt{+/}:  The operator ``\texttt{+/}'' computes the sum of all the elements
      in its argument.  These elements need not be numbers.  They can also be sets, lists,
      or strings.  For example, if $s$ is a set of sets, then the expression 
      \\[0.2cm]
      \hspace*{1.3cm}
      $\texttt{+/}\;s$
      \\[0.2cm]
      computes the union of all sets in $s$.  If $s$ is a list of lists instead, the same
      expression builds a new list by concatenating all lists in $l$.
\item \texttt{*/}:  The operator ``\texttt{*/}'' computes the product of all the elements
      in its argument.  These elements might be  numbers or sets.  In the latter case,
      the operator computes the intersection of all elements.
\item \texttt{><}: If the arguments of the operator ``\texttt{><}'' are sets, then this operator computes the 
      \href{https://en.wikipedia.org/wiki/Cartesian_product}{\emph{Cartesian product}}
      of its arguments.  For example, the expression
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{\{1,2,3\} >< \{8,9\}}
      \\[0.2cm]
      yields the set
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{\{[1,8], [2,8], [3,8], [1,9], [2,9], [3,9]\}}
      \\[0.2cm]
      If, instead, both arguments of this operator are lists, then the expression 
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{l1 >< l2}
      \\[0.2cm]
      \emph{zips} the lists \texttt{l1} and \texttt{l2} into a single list, i.e.~the first element
      of \texttt{l1} is paired with the first element of \texttt{l2}, the second element of
      \texttt{l1} is paired with the second element of \texttt{l2}, and, in general, the
      $i$-th element of \texttt{l1} is paired with the $i$-th element of \texttt{l2}. 
      The resulting pairs are collected in a list, which is the result.
      For example, the expression
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{[1,2] >< [3,4]}
      \\[0.2cm]
      yields the result
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{[[1, 3], [2, 4]]}.
      \\[0.2cm]
      Formally, we can define the function \texttt{zip} as follows:
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{zip := [l1, l2] |-> [ [l1[i], l2[i]] : i in [1 .. \#l1] ];}
      \\[0.2cm]
      Then, if the lists \texttt{l1} and \texttt{l2} have the same length, we have that
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{zip(l1, l2) == l1 >< l2}.
      \\[0.2cm]
      If, instead, the lists \texttt{l1} and \texttt{l2} do not have the same length, then the expression 
      \texttt{l1 >< l2} raises an error.
\item \texttt{arb}: The function $\texttt{arb}(s)$ picks an arbitrary element from the
      sequence $s$.  The argument $s$ can either be a set, a list, or a string.

      \textbf{Note} that an arbitrary element is not the same as a random element.  Instead, the
      element returned by $\texttt{arb}(s)$ will be either the first or the last element of the set
      $s$.  However, this fact is considered an implementation secret and your programs should not
      rely on this behaviour.
\item \texttt{collect}: The function $\texttt{collect}(l)$ takes a list $l$ of arbitrary elements.
      The purpose of this function is to count the number of occurrences of these elements and to
      compute a binary relation $l$ such that for every element $x$ in the list $l$, the binary
      relation $r$ contains a pair of the form $[x,c]$, where $c$ is the number of occurrences of
      $x$ in the list $l$. For example, the expression
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{r := collect(["a", "b", "c", "a", "b", "a"]);}
      \\[0.2cm]
      sets the variable \texttt{r} to the value
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{\{["a", 3], ["b", 2], ["c", 1]\}}.
      \\[0.2cm]
      Note that this value can be used as a binary relation.
\item \texttt{first}: The function $\texttt{first}(s)$ picks the first  element from the
      sequence $s$.  The argument $s$ can either be a set, a list, or a string.
      For a set $s$, the first element is the element that is smallest with respect to the
      function \texttt{compare} discussed in the last section of this chapter.
\item \texttt{last}: The function $\texttt{last}(s)$ picks the last element from the
      sequence $s$.  The argument $s$ can either be a set, a list, or a string.
      For a set $s$, the last element is the element that is greatest with respect to the
      function \texttt{compare} discussed in the last section of this chapter.
\item \texttt{from}: The function $\texttt{from}(s)$ picks an arbitrary element from the
      sequence $s$.  The argument $s$ can either be a set, a list, or a string.  This
      element is removed from $s$ and returned.  This function returns the same element as
      the function \texttt{arb} discussed previously.
\item \texttt{fromB}: The function $\texttt{fromB}(s)$ picks the first element from the
      sequence $s$.  The argument $s$ can either be a set, a list, or a string.  This
      element is 
      removed from $s$ and returned.  This function returns the same element as the
      function \texttt{first} discussed previously.
\item \texttt{fromE}: The function $\texttt{fromB}(s)$ picks the last element from the
      sequence $s$.  The argument $s$ can either be a set, a string, or a list.  This element is
      removed from $s$ and returned.  This function returns the same element as the
      function \texttt{last} discussed previously.
\item \texttt{domain}: If $r$ is a binary relation, then the equality
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{domain(r) = \{ x :[x,y] in R \}}
      \\[0.2cm]
      holds.  For example, we have
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{domain(\{[1,2],[1,3],[5,7]\}) = \{1,5\}}.
\item \texttt{max}:  If $s$ is a set or a list containing only numbers, the expression $\mathtt{max}(s)$ computes the biggest
      element of $s$.  For example, the expression
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{max(\{1,2,3\})}
      \\[0.2cm]
      returns the number $3$.  If $s$ contains elements that are not numbers, then evaluating the
      expression \texttt{max($s$)} raises an error.
\item \texttt{min}:  If $s$ is a set or a list containing only numbers, the expression $\mathtt{min}(s)$ computes the smallest
      element of $s$.  For example, the expression
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{min(\{1,2,3\})}
      \\[0.2cm]
      returns the number $1$.  If $s$ contains elements that are not numbers, then evaluating the
      expression \texttt{min($s$)} raises an error.
\item \texttt{pow}:  If $s$ is a set, the expression $\mathtt{pow}(s)$ computes the 
      \href{https://en.wikipedia.org/wiki/Power_set}{power set} of $s$.  The power set of $s$ is
      defined as the set of all subsets of $s$.  For example, the expression
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{pow(\{1,2,3\})}
      \\[0.2cm]
      returns the set
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{\{\{\}, \{1\}, \{1, 2\}, \{1, 2, 3\}, \{1, 3\}, \{2\}, \{2, 3\}, \{3\}\}}.
\item \texttt{range}: If $r$ is a binary relation, then the equality
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{range(r) = \{ y :[x,y] in R \}}
      \\[0.2cm]
      holds.  For example, we have
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{range(\{[1,2],[1,3],[5,7]\}) = \{2,3,7\}}.
\item \texttt{reverse}: If $l$ is a list or string, then $\mathtt{reverse}(l)$ returns a 
      list or string that contains the elements of $l$ in reverse order.  For example,
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{reverse([1,2,3])}
      \\[0.2cm]
      returns the list
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{[3,2,1]}.
\item \texttt{sort}: If $l$ is a list or string, then $\mathtt{sort}(l)$ sorts $l$ into
      ascending order.  For example,
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{sort([3,2,1])}
      \\[0.2cm]
      returns the list
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{[1,2,3]}.
\end{enumerate}

\section{Functions for String Manipulation}
\setlx\ provides the following functions that are related to strings.
\begin{enumerate}
\item \texttt{+}:  The operator ``\texttt{+}'' concatenates strings.
\item \texttt{*}:  the operator ``\texttt{*}'' repeats a string a given number of times.
      For example, both of the expressions
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{3 * "abc"} \quad and \quad \texttt{"abc" * 3}
      \\[0.2cm]
      yield the result 
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{"abcabcabc"}.
\item \texttt{char}:  For a natural number $n \in \{ 0, 1, 2, \cdots, 127 \}$,  the expression
      \\[0.2cm]
      \hspace*{1.3cm}
      $\mathtt{char}(n)$
      \\[0.2cm]
      computes the character with the 
      \href{https://en.wikipedia.org/wiki/ASCII}{\textsc{Ascii}} code $n$.  For example,
      $\mathtt{char}(65)$ yields the string \texttt{\symbol{34}A\symbol{34}}.

      \textbf{Note} that $\texttt{char}(n)$ is undefined if either $n < 0$ or $n > 127$.
\item \texttt{endsWith}: The function \texttt{endsWith} is called as
      \\[0.2cm]
      \hspace*{1.3cm}
      $\texttt{endsWith}(s,t)$.
      \\[0.2cm]
      Here, both $s$ and $t$ have to be strings.  The function succeeds if the string $t$ is a
      suffix of the string $s$, i.e.~if there is a string $r$ such that the equation
      \\[0.2cm]
      \hspace*{1.3cm}
      $s = r + t$
      \\[0.2cm] 
      holds.
\item \texttt{eval}: The function \texttt{eval}  is called as
      \\[0.2cm]
      \hspace*{1.3cm}
      $\mathtt{eval}(s)$.
      \\[0.2cm]
      Here, $s$ has to be a string that can be parsed as a \setlx\ expression.  This expression
      is then evaluated in the current variable context and the result of this evaluation is
      returned.   Note that $s$ can describe a \setlx\ expression of arbitrary complexity.
      For example, the statement
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{f := eval("procedure(x) \{ return x * x; \}");}
      \\[0.2cm]
      has the same effect as the following statement:
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{f := procedure(x) \{ return x * x; \};}
      \\[0.2cm]
      Defining a function $f$ via $\texttt{eval}(s)$ is useful because the string $s$
      can be the result of an arbitrary computation.  
\item \texttt{execute}: The function \texttt{execute}  is called as
      \\[0.2cm]
      \hspace*{1.3cm}
      $\mathtt{execute}(s)$.
      \\[0.2cm]
      Here, $s$ has to be a string that can be parsed as a \setlx\ statement.  This statement
      is then executed in the current variable context and the result of this evaluation is
      returned.   Note that $s$ can describe a \setlx\ expression of arbitrary complexity.
      For example, the statement
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{execute("f := procedure(x) \{ return x * x; \};");}
      \\[0.2cm]
      has the same effect as the following statement:
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{f := procedure(x) \{ return x * x; \};}
\item \texttt{matches}:  The function \texttt{matches} is called as
      \\[0.2cm]
      \hspace*{1.3cm}
      $\texttt{matches}(s, r)$.
      \\[0.2cm]
      It returns \texttt{true} if the regular expression $r$ matches the string $s$.
      This function can be called with an optional third argument, which must be a Boolean
      value.  In this case, if the last argument is \texttt{true} and the regular
      expression $r$ contains \emph{capturing groups}, i.e.~if parts of the regular
      expression are enclosed in parentheses, then the substrings of the string $s$
      corresponding to these groups are
      captured and the function returns a list of strings:  The first element of this
      list is the string $s$, and the remaining elements are those substrings of $s$ that
      correspond to the different capturing groups.  
      Chapter \ref{chapter:regular-expressions} contains examples demonstrating the use of this function.
      
\item \texttt{join}: The function \texttt{join} is called as
      \\[0.2cm]
      \hspace*{1.3cm}
      $\texttt{join}(s,t)$.
      \\[0.2cm]
      Here, $s$ is either a set or a list.  First, the elements of $s$ are converted into
      strings.  Then these elements are concatenated using the string $t$ as separator.
      For example, the expression
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{join([1,2,3], "*")}
      \\[0.2cm]
      yields the string \texttt{\symbol{34}1*2*3\symbol{34}}.  

      The function \texttt{join} comes in handy to generate comma separated values.
\item \texttt{replace}: The function \texttt{replace} is called as
      \\[0.2cm]
      \hspace*{1.3cm}
      $\mathtt{replace}(s, r, t)$.
      \\[0.2cm]
      Here, $s$ is a string, $r$ is a regular expression, and $t$ is another string.
      Any substring $u$ of the string $s$ that is matched by the regular expression $r$ is
      replaced by the string $t$.  The string resulting from this replacement is returned.
      The string $s$ itself is not changed.
      Chapter \ref{chapter:regular-expressions} contains examples demonstrating the use of this function.

\item \texttt{replaceFirst}: The function \texttt{replaceFirst} is called as
      \\[0.2cm]
      \hspace*{1.3cm}
      $\mathtt{replaceFirst}(s, r, t)$.
      \\[0.2cm]
      Here, $s$ is a string, $r$ is a regular expression, and $t$ is another string.
      The first substring $u$ of the string $s$ that is matched by the regular expression $r$ is
      replaced by the string $t$.  The string resulting from this replacement is returned.
      The string $s$ itself is not changed.
      Chapter \ref{chapter:regular-expressions} contains examples demonstrating the use of this function.

\item \texttt{split}: The function \texttt{split} is called as
      \\[0.2cm]
      \hspace*{1.3cm}
      $\texttt{split}(s,t)$.
      \\[0.2cm]
      Here, $s$ and $t$ have to be strings.  $t$ can either be a single character or 
      a regular expression. The call $\mathtt{split}(s, t)$ splits the string $s$ at all
      occurrences of $t$.  The resulting parts of $s$ are collected into a list.
      If $t$ is the empty string, the string $s$ is split into all of its characters.
      For example, the expression
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{split("abc", "");}
      \\[0.2cm]
      returns the list \texttt{["a", "b", "c"]}.  As another example,
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{split("abc  xy z", " +");}
      \\[0.2cm]
      yields the list
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{["abc", "xy", "z"]}.
      \\[0.2cm]
      Note that we have used the regular expression ``\texttt{+}'' to specify one or more
      blank characters.

      Certain \emph{magic} characters, i.e.~all those characters that serve as operator
      symbols in regular expressions have to be escaped if they are intended as split
      characters.  Escaping is done by prefixing two backslash symbols to the respective 
      character as in the following example:
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{split("abc|xyz", '\symbol{92}|');}
      \\[0.2cm]
      The function \texttt{split} is very handy when processing comma separated values from
      \textsc{CSV} files.
\item \texttt{str}:  The function \texttt{str} is called as
      \\[0.2cm]
      \hspace*{1.3cm}
      $\texttt{str}(a)$
      \\[0.2cm]
      where the argument $a$ can be anything.  This function computes the string
      representation of $a$.  For example, after defining the function \texttt{f} as
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{f := procedure(n) \{ return n * n; \};}
      \\[0.2cm]
      the expression \texttt{str(f)} evaluates to the string
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{"procedure(n) \{ return n * n; \}"}.      
\item \texttt{toLowerCase}:  Given a string $s$, the expression $\texttt{toLowerCase}(s)$
      converts all characters of $s$ to lower case.
\item \texttt{toUpperCase}:  Given a string $s$, the expression $\texttt{toUpperCase}(s)$
      converts all characters of $s$ to upper case.
\item \texttt{trim}:  Given a string $s$, the expression $\mathtt{trim}(s)$ returns a
      string that is the result of removing all leading or trailing white space characters from the
      string $s$.  For example, the expression
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{trim("  abc xyz\symbol{92}n")}
      \\[0.2cm]
      returns the string \texttt{\symbol{34}abc xyz\symbol{34}}.
\end{enumerate}

\section{Functions for Term Manipulation}
The following functions support terms.
\begin{enumerate}
\item \texttt{args}:  Given a term $t$ that has the form
      \\[0.2cm]
      \hspace*{1.3cm}
      $F(s_1, \cdots, s_n)$,
      \\[0.2cm]
      the expression $\mathtt{args}(t)$ returns the list
      \\[0.2cm]
      \hspace*{1.3cm}
      $[s_1, \cdots, s_n]$.
\item \texttt{evalTerm}: This function is called as
      \\[0.2cm]
      \hspace*{1.3cm}
      $\mathtt{evalTerm}(t)$.
      \\[0.2cm]
      Here, $t$ has to be a term that represents a  \setlx\ expression.  This expression
      is then evaluated in the current variable context and the result of this evaluation is
      returned.   For convenience, the term $t$ can be produced by the function \texttt{parse}.
      For example, the statement
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{f := evalTerm(parse("procedure(x) \{ return x * x; \}"));}
      \\[0.2cm]
      has the same effect as the following statement:
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{f := procedure(x) \{ return x * x; \};}
      \\[0.2cm]
      The function \texttt{evalTerm} is an advanced feature of \setlx\ that allows for
      self modifying programs.  This idea is that a function definition given as a string can be
      transformed into a term.  This term can then be manipulated using the facilities provided
      by the \texttt{match} statement and the modified term can finally be evaluated using
      \texttt{evalTerm}. 
\item \texttt{fct}:  Given a term $t$ that has the form
      \\[0.2cm]
      \hspace*{1.3cm}
      $F(s_1, \cdots, s_n)$,
      \\[0.2cm]
      the expression $\mathtt{fct}(t)$ returns the functor $F$.
\item \texttt{getTerm}: The function \texttt{getTerm}  is called as
      \\[0.2cm]
      \hspace*{1.3cm}
      $\mathtt{getTerm}(v)$.
      \\[0.2cm]
      It returns a term representing the value $v$.  
      For example, the expression
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{canonical(getTerm(procedure(n) \{ return n * n; \}))}
      \\[0.2cm]
      produces the following output:
\begin{verbatim}
@@@procedure([@@@parameter("n", "nil")], 
             @@@block(
                 [@@@return(@@@product(@@@variable("n"), @@@variable("n")))]
             )
            )
\end{verbatim}
      The funny looking function symbols that are preceded by three occurrences of the character
      ``\texttt{\symbol{64}}'' are the functors that are used by \setlx\ internally.

      However, there is one twist when evaluating $\texttt{getTerm}(v)$: If $v$ is either a set or a list,
      then $\texttt{getTerm}(v)$ transforms the elements of $v$ into terms and returns the
      resulting set or list.  
\item \texttt{makeTerm}: Given a functor $F$ and a list $l = [s_1, \cdots, s_n]$,
      the expression
      \\[0.2cm]
      \hspace*{1.3cm}
      $\mathtt{makeTerm}(F, [s_1, \cdots, s_n])$
      \\[0.2cm]
      returns the term
      \\[0.2cm]
      \hspace*{1.3cm}
      $F(s_1, \cdots, s_n)$.
\item \texttt{canonical}:  Given a term $t$, the expression $\mathtt{canonical}(t)$
      returns a string that is the canonical representation of the term $t$.  The 
      point is, that all operators in $t$ are replaced by functors that denote
      these operators internally.  For example, the expression
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{canonical(parse("x+2*y"));}
      \\[0.2cm]
      yields the string
\begin{verbatim}
      @@@sum(@@@variable("x"), @@@product(2, @@@variable("y")))
\end{verbatim}
      This shows that, internally, variables are represented using the functor
      ``\texttt{\symbol{64}\symbol{64}\symbol{64}variable}'' and that the operator ``\texttt{+}'' is represented by
      the functor ``\texttt{\symbol{64}\symbol{64}\symbol{64}sum}''.
\item \texttt{parse}:  Given a string $s$ that is a valid expression in \setlx, the expression
      \\[0.2cm]
      \hspace*{1.3cm}
      $\mathtt{parse}(s)$ 
      \\[0.2cm]
      tries to parse the string $s$ into a term.  In order to visualize the structure of
      this term,  the function \texttt{canonical} discussed above can be used.      
\item \texttt{parseStatements}:  Given a string $s$, the expression
      \\[0.2cm]
      \hspace*{1.3cm}
      $\mathtt{parseStatements}(s)$ 
      \\[0.2cm]
      tries to parse the string $s$ as a sequence of \setlx\ statements.   In order to visualize the structure of
      this term,  the function \texttt{canonical} discussed above can be used.  For
      example, the expression
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{canonical(parseStatements("x := 1; y := 2; z := x + y;"));}
      \\[0.2cm]
      yields the following term (which has been formatted for enhanced readability):
\begin{verbatim}
@@@block([@@@assignment(@@@variable("x"), 1), 
          @@@assignment(@@@variable("y"), 2), 
          @@@assignment(@@@variable("z"), @@@sum(@@@variable("x"), @@@variable("y")))
       ])
\end{verbatim}
\end{enumerate}

\subsection{Library Functions for Term Manipulation}
Beside the predefined functions discussed above, the library ``\texttt{termUtilities}'' implements
three functions that process terms.  This library is loaded via the command
\\[0.2cm]
\hspace*{1.3cm}
\texttt{loadLibrary("termUtilities");}
\\[0.2cm]
After loading this library, the following functions will be available.
\begin{enumerate}
\item $\texttt{toTerm}(t)$:  This function takes a term $t$ that has been produced by a call to the function
      \texttt{parse}.  This term is then simplified into a more natural structure.  For example, if we issue
      the command
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{t := parse(exp(x));}
      \\[0.2cm] 
      and then inspect the term \texttt{t} using the command
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{canonical(t);}
      \\[0.2cm]
      the result is
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{@@@call(@@@variable("exp"), [@@@variable("x")], "nil")}.
      \\[0.2cm]
      For many applications, the structure of this term is too complicated.  We can simplify the
      term \texttt{t} using the function \texttt{toTerm}.  After the statement
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{s := toTerm(t);}
      \\[0.2cm]
      we can check that the term \texttt{s} is indeed simpler using the command
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{canonical(s);}
      \\[0.2cm]
      In this case, the result is
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{@exp(@@@variable("x"))}.
\item $\texttt{parseTerm}(t)$:  Usually, the function \texttt{toTerm} is used to simplify the result
      of the predefined function \texttt{parse}.  The function \texttt{parseTerm} combines these two functions. 
      It is defined as follows:
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{parseTerm := s |-> toTerm(parse(s)); }
\item $\texttt{fromTerm}(t)$:  The function \texttt{fromTerm} takes a term $t$ and translates it
      back into the internal structure required by the function \texttt{evalTerm}.  This function
      can be seen as an inverse of the function \texttt{toTerm}, i.e.~we have
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{fromTerm(toTerm(t)) = t}
      \\[0.2cm]
      provided \texttt{t} is a term produced by the function \texttt{parse}.
\end{enumerate}



\section{Mathematical Functions}
The function \setlx\ provides the following mathematical functions.
\begin{enumerate}
\item The operators 
      ``\texttt{+}'',
      ``\texttt{-}'',
      ``\texttt{*}'',
      ``\texttt{/}'', and
      ``\texttt{\symbol{37}}'' compute the sum, the difference, the product, the quotient,
      and the remainder of its operands.  The remainder $a\, \texttt{\symbol{37}}\, b$ is
      defined so that it satisfies
      \\[0.2cm]
      \hspace*{1.3cm}
      $0 \leq a \,\texttt{\symbol{37}}\, b$ \quad and \quad $a \,\texttt{\symbol{37}}\, b < b$.
\item The operator ``\texttt{\symbol{92}}'' computes integer division of its arguments.
      For two integers $a$ and $b$, this is defined such that 
      \\[0.2cm]
      \hspace*{1.3cm}
      $a = (a\texttt{\symbol{92}} b) \,\texttt{*}\, b + a \,\texttt{\symbol{37}}\, b$
      \\[0.2cm]
      holds.
\item $\texttt{abs}(x)$ calculates the absolute value of the number $x$.
\item $\texttt{ceil}(x)$ calculates the
      \href{https://en.wikipedia.org/wiki/Floor_and_ceiling_functions}{\emph{ceiling function}} of $x$.
      Mathematically, 
      $\mathtt{ceil}(x)$ is defined as the smallest integer that is bigger than or equal
      to $x$:
      \\[0.2cm]
      \hspace*{1.3cm}
      $\texttt{ceil}(x) := \min \{ n \in \mathbb{Z} \mid x \leq n \}$.
      \\[0.2cm]
      For example, we have
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{ceil(2.1) = 3}.
\item $\texttt{floor}(x)$ calculates the
      \href{https://en.wikipedia.org/wiki/Floor_and_ceiling_functions}{\emph{floor function}}  of $x$.
      Mathematically, $\mathtt{floor}(x)$ is defined as the largest integer that is less than or equal
      to $x$:
      \\[0.2cm]
      \hspace*{1.3cm}
      $\texttt{floor}(x) := \max \{ n \in \mathbb{Z} \mid n \leq x \}$.
      \\[0.2cm]
      For example, we have
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{floor(2.9) = 2}.
\item $\texttt{mathConst}(\textsl{name})$ can be used to compute mathematical constants.
      At the moment, and $\pi$, Euler's number $e$, and infinity are supported.  Therefore, the expression
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{mathConst(\symbol{34}pi\symbol{34}})
      \\[0.2cm]
      yields the result $3.141592653589793$, while
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{mathConst(\symbol{34}e\symbol{34}})
      \\[0.2cm]
      yields $2.718281828459045$.  To get a number of infinite size, we can write
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{mathConst(\symbol{34}infinity\symbol{34}}).
      \\[0.2cm]
      \setlx\ supports a little bit of arithmetic using $\infty$.  For example,  the expression
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{mathConst("infinity") - 42}
      \\[0.2cm]
      evaluates to infinity, while
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{1 / mathConst("infinity")}
      \\[0.2cm]
      evaluates to $0$.  However, expressions like
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{mathConst("infinity") - mathConst("infinity");}
      \\[0.2cm]
      do not have a meaningful interpretation and result in an error message.
\item $\mathtt{nextProbablePrime}(n)$ returns the next 
      \href{https://en.wikipedia.org/wiki/Probable_prime}{probable prime number} that is greater than
      $n$.  Here, $n$ needs to be a natural number.   The probability that the result of 
      $\mathtt{nextProbablePrime}(n)$ is not a prime number is less than $2^{-100}$.
      For example, to find the smallest prime number greater than 1000 we can use the expression
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{nextProbablePrime(1000)}.
\item $\texttt{int}(s)$ converts the string $s$ into a number.
      The function \texttt{int} can also be called if $s$ is already a
      number.  In this case,  if $s$ is an integer number, it is returned unchanged.  Otherwise,
      the floating point part is truncated.  Therefore, the expression
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{int(2.9)}
      \\[0.2cm]
      returns the integer \texttt{2}.
\item $\mathtt{rational}(s)$ converts the string $s$ into a rational number.  For example
      the expression
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{rational(\symbol{34}2/7\symbol{34})}
      \\[0.2cm]
      will return the rational number $2/7$.  The function \texttt{rational} can also be
      invoked on floating point numbers.  For example, the expression 
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{rational(mathConst("e"))}
      \\[0.2cm]
      yields the result $6121026514868073/2251799813685248$.  
      The expression $\mathtt{rational}(q)$ returns $q$ if $q$ is already a rational number.
\item $\texttt{double}(s)$ converts the string $s$ into a floating point number.  For example
      the expression
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{double(\symbol{34}0.5\symbol{34})}
      \\[0.2cm]
      will return the floating point number $0.5$.  The function \texttt{double} can also be
      invoked on rational numbers.  For example, the expression 
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{double(2/7)}
      \\[0.2cm]
      yields  $0.2857142857142857$.
      The expression $\mathtt{double}(r)$ returns $r$ if $r$ is already a floating point
      number.

      The implementation of floating point numbers is based on the \textsl{Java} class
      \texttt{Double}.  Therefore, floating point numbers satisfy the specification given in the
      IEEE standard 754 for the arithmetic of floating point numbers.
\item Furthermore, the 
      \href{https://en.wikipedia.org/wiki/Trigonometric_functions}{trigonometric functions} 
      \texttt{sin}, \texttt{cos}, \texttt{tan} and the associated 
      \href{https://en.wikipedia.org/wiki/Inverse_trigonometric_functions}{inverse trigonometrical functions}
      \texttt{asin}, \texttt{acos}, and \texttt{atan}
      are supported.  For example, the expression
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{sin(mathConst(\symbol{34}pi\symbol{34})/2);}
      \\[0.2cm]
      yields $1.0$.
\item The functions $\texttt{atan2}(y,x)$ and $\texttt{hypot}(x,y)$ are useful when converting 
      a point $\langle x, y \rangle$ from
      \href{https://en.wikipedia.org/wiki/Cartesian_coordinate_system}{Cartesian coordinates} 
      into \href{https://en.wikipedia.org/wiki/Polar_coordinate_system}{polar coordinates}.  If a
      point $p$ has Cartesian coordinates $\langle x, y \rangle$ and polar coordinates 
      $\langle r, \varphi \rangle$, then 
      \\[0.2cm]
      \hspace*{1.3cm}
      $\varphi = \mathtt{atan2}(y,x)$ \quad and \quad $r = \mathtt{hypot}(x, y)$.
      \\[0.2cm]
      Therefore, $\texttt{hypot}(x,y) = \sqrt{x^2 + y^2}$, while as long as both $x > 0$ and $y > 0$
      we have
      \\[0.2cm]
      \hspace*{1.3cm}
      $\mathtt{atan2}(y,x) = \mathtt{atan}\bigl(\frac{y}{x}\bigr)$.
\item \texttt{exp($x$)} computes the
      \href{https://en.wikipedia.org/wiki/Exponential_function}{exponential function} of $x$, 
      i.e.~$\mathtt{exp}(x)$ computes $e^x$ where $e$ is 
      \href{https://en.wikipedia.org/wiki/E_(mathematical_constant)}{Euler's number}.  Therefore, the
      expression 
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{exp(1)}
      \\[0.2cm]
      yields $2.718281828459046$.
\item $\texttt{expm1}(x)$ computes $e^x - 1$.  This function is useful when computing values of
      $e^x$ where the absolute value of $x$ is very small.
\item \texttt{log($x$)} computes the 
      \href{https://en.wikipedia.org/wiki/Natural_logarithm}{natural logarithm} of $x$.  This function is the
      inverse function of the exponential function \texttt{exp}.  Therefore, we have
      the equation
      \\[0.2cm]
      \hspace*{1.3cm}
      $\mathtt{log}(\mathtt{exp}(x)) = x$.
      \\[0.2cm]
      This equation is valid as long as there is no overflow in the computation of
      $\mathtt{exp}(x)$.
\item $\mathtt{log1p}(x)$ computes $\mathtt{log}(x + 1)$, where $\mathtt{log}$ denotes the natural
      logarithm.  This function should be used to compute $\log(y)$ for values of $y$ such that $y - 1$ is small.
\item \texttt{log10($x$)} computes the base 10 logarithm of $x$.
\item \texttt{sqrt($x$)} computes the \href{https://en.wikipedia.org/wiki/Square_root}{square root}
      of $x$, i.e.~it computes $\sqrt{x}$.  Therefore, as long as $x$ is small enough so that there
      is no overflow when computing $x\mathtt{*}x$, the equation 
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{sqrt($x$*$x$)$=x$}
      \\[0.2cm]
      is valid.
\item \texttt{cbrt($x$)} computes the \href{https://en.wikipedia.org/wiki/Cube_root}{cube root} of
      $x$, i.e.~we have $\mathtt{cbrt}(x) = \sqrt[3]{x}$.  Therefore, as long as $x$ is not too large, the equation
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{cbrt($x$*$x$*$x$) $= x$}
      \\[0.2cm]
      is valid.
\item $\texttt{round}(x)$ rounds the number $x$ to the nearest integer.
\item $\texttt{nDecimalPlaces}(q, n)$ takes a positive rational number $q$ and a positive natural
      number $n$ as arguments.  It converts the rational number $q$ into a string that denotes the
      value of $q$ in decimal floating point notation.  This string contains $n$ digits after the
      decimal point.  Note that these digits are truncated, there is no rounding
      involved.  For example, the expression
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{nDecimalPlaces(2/3,5)}
      \\[0.2cm]
      yields the string ``\texttt{0.66666}'', while 
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{nDecimalPlaces(1234567/3,5)} returns ``\texttt{411522.33333}''.
\item $\mathtt{ulp}(x)$  returns the difference between the floating point number $x$ and
      the smallest floating point number bigger than $x$.  For example, when working with
      64 bits floating point numbers (which is the default), we have
      \\[0.2cm]
      \hspace*{1.3cm}
      $\mathtt{ulp}(1.0) = \texttt{2.220446049250313E-16}$.
      \\[0.2cm]
      \texttt{ulp} is the abbreviation for 
      \href{https://en.wikipedia.org/wiki/Unit_in_the_last_place}{\emph{\underline{u}nit in the \underline{l}ast \underline{p}lace}}. 
\item $\mathtt{signum}(x)$ computes the 
      \href{https://en.wikipedia.org/wiki/Sign_function}{sign function} of $x$.  If $x$ is positive,
      the result is $1.0$, if $x$ is negative, the result is $-1.0$.  If $x$ is zero,
      $\mathtt{signum}(x)$ is also zero.
\item $\texttt{sinh}(x)$ computes the
      \href{https://en.wikipedia.org/wiki/Hyperbolic_function}{hyperbolic} sine of $x$.  
      Mathematically, the hyperbolic sine of $x$ is defined as 
      \\[0.2cm]
      \hspace*{1.3cm}
      $\mathtt{sinh}(x) := \frac{1}{2} \cdot \bigl(e^x - e^{-x}\bigr)$.
\item $\texttt{cosh}(x)$ computes the
      \href{https://en.wikipedia.org/wiki/Hyperbolic_function}{hyperbolic} cosine of $x$.
      Mathematically, the hyperbolic cosine of $x$ is defined as 
      \\[0.2cm]
      \hspace*{1.3cm}
      $\mathtt{cosh}(x) := \frac{1}{2} \cdot \bigl(e^x + e^{-x}\bigr)$.
\item $\texttt{tanh}(x)$ computes the
      \href{https://en.wikipedia.org/wiki/Hyperbolic_function}{hyperbolic} tangent of $x$.  
      Mathematically, the hyperbolic tangent of $x$ is defined as 
      \\[0.2cm]
      \hspace*{1.3cm}
      $\mathtt{tanh}(x) := \displaystyle \frac{\;\mathtt{sinh}(x)\;}{\mathtt{cosh}(x)}$.
\item $\texttt{isPrime}(x)$ tests whether its argument is a 
      \href{https://en.wikipedia.org/wiki/Prime_number}{prime number}.  Currently, 
      this function has a naive implementation and is therefore not efficient.
\item $\texttt{isProbablePrime}(x)$ tests whether its argument is a
      \href{https://en.wikipedia.org/wiki/Prime_number}{prime number}.  The test 
      used is 
      \href{https://en.wikipedia.org/wiki/Miller-Rabin-primality_test}{probabilistic}.  If
      $x$ is indeed  prime, the test $\texttt{isProbablePrime}(x)$ 
      will always succeed.  If $x$ is not prime, the predicate $\texttt{isProbablePrime}(x)$
      might nevertheless return \texttt{true}.  However, the probability that this happens
      is less than $2^{-30}$.

      It should be noticed that the implementation of \texttt{isProbablePrime} is
      based on random numbers.  Therefore, in rare cases different invocations of
      \texttt{isProbablePrime} might return different results.  
\end{enumerate}


\section{Generating Random Numbers and Permutations}
In order to generate random numbers, \setlx\ provides the functions \texttt{rnd} and
\texttt{random}.  The easiest to use of these function is \texttt{random}.  The expression
\\[0.2cm]
\hspace*{1.3cm}
$\texttt{random}()$
\\[0.2cm]
generates a random number $x$ such that 
\\[0.2cm]
\hspace*{1.3cm}
$0 \leq x$ \quad and \quad $x \leq 1$
\\[0.2cm]
holds.  This will be a floating point number with 64 bits.  For debugging purposes it might be necessary to start \setlx\ with
the parameter
\\[0.2cm]
\hspace*{1.3cm}
\texttt{--predictableRandom}.
\\[0.2cm]
In this case, the sequence of random numbers that is generated by the function \texttt{random} and
\texttt{rnd} is always the same.  This is useful when debugging a program working with
random numbers.  The function 
\\[0.2cm]
\hspace*{1.3cm}
\texttt{resetRandom()}
\\[0.2cm]
provides another way to reset the random number generator to its initial state.

The function \texttt{random} can also be called with an argument.  The expression
\\[0.2cm]
\hspace*{1.3cm}
$\texttt{random}(n)$
\\[0.2cm]
is equivalent to the expression
\\[0.2cm]
\hspace*{1.3cm}
\texttt{$n$ * random()}.
\\[0.2cm]
The function \texttt{rnd} has a number of different uses.  
\begin{enumerate}
\item If $l$ is either a list or a set, then the expression
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{rnd($l$})
      \\[0.2cm]
      returns a random element of $l$.
\item If $n$ is an natural number, then 
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{rnd($n$)}
      \\[0.2cm]
      returns a natural number $k$ such that we have
      \\[0.2cm]
      \hspace*{1.3cm}
      $0 \leq k$ and $k \leq n$.
\item If $n$ is a negative number, then 
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{rnd($n$)}
      \\[0.2cm]
      returns a negative number $k$ such that we have
      \\[0.2cm]
      \hspace*{1.3cm}
      $n \leq k$ \quad and \quad $k \leq 0$.
\item In order to generate random rational numbers, the function \texttt{rnd} has to be called with
      two arguments.  The expression
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{rnd($a$/$b$, $n$)}
      \\[0.2cm]
      is internally translated into the expression
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{rnd($n-1$) * a / ($b$ * ($n-1$))}.
      \\[0.2cm]
      Therefore, if $a$ is positive, the number returned is a random number between $0$ and the
      fraction $a/b$ and there will be $n$ different possibilities, so the parameter $n$ is used to
      control the granularity of the results.  For example,  the expression 
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{rnd(1/2,6)}
      \\[0.2cm]
      can return any of the following six fractions:
      \\[0.2cm]
      \hspace*{1.3cm}
      $0$, $1/10$, $2/10$, $3/10$, $4/10$, $5/10$,
      \\[0.2cm]
      while the expression \texttt{rnd(1/2,101)} could return $101$ different results, namely any
      fraction of the form
      \\[0.2cm]
      \hspace*{1.3cm}
      $a/200$ \quad such that $a \in \{0, 1, \cdots 100\}$.
      \\[0.2cm]
      Of course, the user will never see a result of the form $100/200$ as this is immediately
      reduced to $1/2$. 

      The second parameter also works if the first argument is a natural number.  For example, the
      expression \texttt{random(1,11)} returns one of the following eleven fractions:
      \\[0.2cm]
      \hspace*{1.3cm}
      $0$, $1/10$, $2/10$, $3/10$, $4/10$, $5/10$,
      $6/10$, $7/10$, $8/10$, $9/10$, $10/10$.      
\end{enumerate}

\subsection{\texttt{shuffle}}
The function \texttt{shuffle} shuffles a list or string
randomly.  For example, the expression
\\[0.2cm]
\hspace*{1.3cm}
\texttt{shuffle(\symbol{34}abcdef\symbol{34})}
\\[0.2cm]
might yield the result \texttt{\symbol{34}dfbaec\symbol{34}}, while 
\\[0.2cm]
\hspace*{1.3cm}
\texttt{shuffle([1,2,3,4,5,6,7])}
\\[0.2cm]
might yield the list \texttt{[1, 7, 4, 6, 3, 5, 2]}.

\subsection{\texttt{nextPermutation}}
The function \texttt{nextPermutation} can be used to enumerate all possible 
\href{https://en.wikipedia.org/wiki/Permutation}{permutations}
of a given list or string.  For example, the function \texttt{printAllPermutations} shown
in Figure \ref{fig:allPermutations.stlx} prints all permutations of a given list or string.
Evaluation of the expression
\\[0.2cm]
\hspace*{1.3cm}
\texttt{printAllPermutations([1,2,3])}
\\[0.2cm]
yields the following output:
\begin{verbatim}
    [1, 2, 3]
    [1, 3, 2]
    [2, 1, 3]
    [2, 3, 1]
    [3, 1, 2]
    [3, 2, 1]
\end{verbatim}

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    printAllPermutations := procedure(l) {
        while (l != om) {
            print(l);
            l := nextPermutation(l);        
        }
    };
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Printing all permutations of a given list or string.}
\label{fig:allPermutations.stlx}
\end{figure}

\subsection{\texttt{permutations}}
Given a set, list or string $l$, the expression
\\[0.2cm]
\hspace*{1.3cm}
\texttt{permutations}($l$)
\\[0.2cm]
returns a set of all \href{https://en.wikipedia.org/wiki/Permutation}{permutations} of $l$.  For
example, the expression 
\\[0.2cm]
\hspace*{1.3cm}
\texttt{permutations("abc")}
\\[0.2cm]
returns the set
\\[0.2cm]
\hspace*{1.3cm}
\texttt{\{"abc", "acb", "bac", "bca", "cab", "cba"\}}.
\\[0.2cm]
Likewise, the expression
\\[0.2cm]
\hspace*{1.3cm}
\texttt{permutations(\{1, 2, 3\})}
\\[0.2cm]
yields the result
\\[0.2cm]
\hspace*{1.3cm}
\texttt{\{[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]\}}.

\section{Type Checking Functions}
\setlx\ provides the following functions to check the type of a given function.
\begin{enumerate}
\item \texttt{isBoolean} tests whether its argument is a Boolean value.
\item \texttt{isDouble} tests whether its argument is a floating point number. 
\item \texttt{isError} tests whether its argument is an error object.

      For example, consider the following code:
      \begin{verbatim}
      try { throw("foo"); } catch (e) { print(isError(e)); }
      \end{verbatim}
      \vspace*{-0.5cm}

      Here, the exception $e$ that gets caught has been thrown by the user and therefore
      is not considered an error object.  Hence, this program fragment prints \texttt{false}.
      However, the program fragment
      \begin{verbatim}
      try { om+1; } catch (e) { print(isError(e)); }
      \end{verbatim}
      \vspace*{-0.5cm}

      will indeed print \texttt{true}, as the evaluation of \texttt{om+1}
      raises an exception that signifies an error.
\item \texttt{isInfinite} tests whether its argument is a floating point number that represents
      either positive or negative infinity.
\item \texttt{isInteger} tests whether its argument is an integer number.
\item \texttt{isList} tests whether its argument is a list.
\item \texttt{isMap} tests whether its argument is a binary relation that maps every
      element in its domain \emph{uniquely} into an element of its range.  Therefore, a
      binary relation $r$ is not a map if it contains two pairs
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{[$x$,$y_1$]} \quad and \texttt{[$x$,$y_2$]}
      \\[0.2cm]
      such that $y_1 \not= y_2$.
\item \texttt{isNumber} tests whether its argument is a number.
\item \texttt{isProcedure} tests whether its argument is a procedure.
\item \texttt{isRational} tests whether its argument is a rational number.
\item \texttt{isSet} tests whether its argument is a set.
\item \texttt{isString} tests whether its argument is a string.
\item \texttt{isTerm} tests whether its argument is a term.
\item \texttt{isObject} tests whether its argument is an object.
\end{enumerate}

\section{Debugging}
\setlx\ supports a few functions to help with debugging:
\begin{enumerate}
\item \texttt{trace}:  This function is called as either
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{trace(true)} \quad or \quad \texttt{trace(false)}.
      \\[0.2cm]
      The expression \texttt{trace(true)} switches tracing on:  Afterwards, all
      assignments are written to the terminal window running \setlx.  To switch tracing
      of, call \texttt{trace(false)}.
\item \texttt{stop}:  The function \texttt{stop}  is called as
      \\[0.2cm]
      \hspace*{1.3cm}
      $\texttt{stop}(\textsl{id})$.
      \\[0.2cm]
      Here, the optional parameter \textsl{id} is a string that reminds you
      of the location in the program where it was inserted. When executed, this function produces a
      prompt.  Confirm with no input to continue the execution, or enter comma separated variable
      names to display their current value. Enter `All' to display all variables in the current scope.
      This function always returns zero, therefore it is often possible to call this function inside expressions.
\item \texttt{assert}: The function \texttt{assert}  is called as
      \\[0.2cm]
      \hspace*{1.3cm}
      $\texttt{assert}(\textsl{condition}, \textsl{msg})$.
      \\[0.2cm]
      Here, \textsl{condition} is an expression that has to  yield either \texttt{true} or \texttt{false}
      when evaluated. If the \textsl{condition} is true, the function \texttt{assert} has no
      further effect.  However, if the evaluation of \textsl{condition} yields the value
      \texttt{false}, then the execution of the program is terminated and the error message
      \textsl{msg} is printed.

      \setlx\ has an option ``\texttt{--noAssert}''.  The short form of this option is ``\texttt{-a}''.
      If this option is activated, the function \texttt{assert} is not evaluated.  Hence,  in order
      to speed up the program, this option can be used to switch off all assertions.      
\end{enumerate}

\subsection{Library Functions for Debugging}
The library \texttt{debugUtilities} offers more sophisticated procedures for tracing than the
predefined procedure \texttt{trace} which either traces everything or nothing.  The library
\texttt{debugUtilities} has to be loaded using the command
\\[0.2cm]
\hspace*{1.3cm}
\texttt{loadLibrary(debugUtilities);}
\\[0.2cm]
In order to trace a specific procedure, we first need to create a tracer using the command
\\[0.2cm]
\hspace*{1.3cm}
\texttt{myTracer := tracer();}
\\[0.2cm]
Then, a procedure with the name $f$ can be traced via the command
\\[0.2cm]
\hspace*{1.3cm}
\texttt{$f$ := myTracer.trace($f$, "$f$");}
\\[0.2cm]
To deactivate tracing of the function $f$, the command
\\[0.2cm]
\hspace*{1.3cm}
\texttt{$f$ := myTracer.untrace("$f$");}
\\[0.2cm]
can be used.  This is explained in more detail in Section \ref{sec:decorators}. 

Besides tracing, the library \texttt{debugUtilities} also supports a very simple form of
\href{https://en.wikipedia.org/wiki/Profiling_(computer_programming)}{\emph{profiling}}, i.e.~the
measurement of execution times of a procedure.  To this end, the library "\texttt{debugUtilities}"
contains the class \texttt{profiler}.  This class offers the function \texttt{profile}.  This
function is called as follows:
\\[0.2cm]
\hspace*{1.3cm}
\texttt{$p$.profile($f$, "$f$");}
\\[0.2cm]
Here, $p$ is an object of the class \texttt{profiler} and $f$ is the name of a function.  An example
will clarify the idea.  Figure \ref{fig:fibonacci-timed.stlx} on page
\pageref{fig:fibonacci-timed.stlx} shows a naive computation of the 
\href{https://en.wikipedia.org/wiki/Fibonacci_number}{Fibonacci numbers} that makes use of the
method \texttt{profile}.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    loadLibrary("debugUtilities");
    
    fibonacci := procedure(n) {
        if (n in [0,1]) {
            return n;
        }
        return fibonacci(n-1) + fibonacci(n-2);
    };
    
    p := profiler();
    fibonacci := p.profile(fibonacci, "fibonacci");
    
    for (n in [10 .. 32]) {
        start := p.mTimes["fibonacci"];
        fibonacci(n);
        stop  := p.mTimes["fibonacci"];
        print("$n$: $stop - start$");
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Profiling the Fibonacci function.}
\label{fig:fibonacci-timed.stlx}
\end{figure}

\begin{enumerate}
\item First, we need to load the library \texttt{debugUtilities} in line 1.
\item Line 3 -- 8 provide the implementation of the function \texttt{fibonacci}.  This function is
      called with an integer argument $n$ and \texttt{fibonacci($n$)} computes the $n$-th Fibonacci
      number.  Since we want to demonstrate profiling, the implementation given here is, on purpose,
      inefficient.  
\item Line 10 creates a profiler \texttt{p}.
\item Line 11 initiates profiling of the function \texttt{fibonacci}.
\item In line 13 -- 18 we compute the $n$-th Fibonacci number for $n \in \{20, \cdots, 32\}$.
\item Every time the function \texttt{fibonacci} is called, the accumulated running time of all
      invocations of the function \texttt{fibonacci} is stored in the dictionary \texttt{p.mTimes}
      under the key \texttt{"fibonacci"}.  Hence the expression 
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{p.mTimes["fibonacci"]}
      \\[0.2cm]
      in line 14 yields the time spent so far to compute the Fibonacci numbers up to the
      $n\!-\!1$-th Fibonacci number in milliseconds, while the same expression in line 16 yields the
      time spent to compute all Fibonacci numbers up to the $n$-th Fibonacci number.  Therefore,
      the difference 
      \\[0.2cm]
      \hspace*{1.3cm}
      $\texttt{stop}-\texttt{start}$ 
      \\[0.2cm]
      is the time to compute the $n$-th Fibonacci number.
\item The output of this program is shown in Figure \ref{fig:fibonacci-timed-out}.  This output
      clearly shows that the time needed to compute the $n$-th Fibonacci number increases
      exponentially with $n$.
\end{enumerate}

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    20: 1005
    21: 1952
    22: 2802
    23: 5604
    24: 9547
    25: 12699
    26: 21346
    27: 36260
    28: 60400
    29: 102612
    30: 172454
    31: 288334
    32: 482399
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Output of the program shown in Figure \ref{fig:fibonacci-timed.stlx}}
\label{fig:fibonacci-timed-out}
\end{figure}

Besides the procedure \texttt{profile}, the class \texttt{profiler} also implements the procedure
\texttt{unprofile} that stops profiling of its argument.  It is called as
\\[0.2cm]
\hspace*{1.3cm}
\texttt{$p$.unprofile("$f$");}
\\[0.2cm]
Here, $p$ needs to be the same instance of the class \texttt{profiler} that has been used to
initiate profiling of the function $f$. 

\section{I/O Functions}
This  section lists all functions related to input and output.

\subsection{\texttt{appendFile}}
The function \texttt{appendFile} is called as
\\[0.2cm]
\hspace*{1.3cm}
$\mathtt{appendFile}(\textsl{fileName}, l)$.
\\[0.2cm]
Here, \textsl{fileName} is a string denoting the name of a file, while $l$ is a list of
strings.  If file a with the specified name does not exist, it is created.  Then the strings
given in $l$ are appended to the file.   Each string written to the specified file is
automatically  terminated by a newline character.

\subsection{\texttt{ask}}
The function \texttt{ask} is called as
\\[0.2cm]
\hspace*{1.3cm}
$\mathtt{ask(\textsl{question}, \textsl{answerList})}$.
\\[0.2cm]
Here, \textsl{question} is a string that is printed and \textsl{answerList} is a list of all
possible answers that the user can choose from.  For example, imagine you are programming some
support application for the US judicial system and your program has to ask your customer a difficult
question.  The call
\\[0.2cm]
\hspace*{1.3cm}
\texttt{ask("How would you like to die?", ["electrocution", "intoxination"]);}
\\[0.2cm]
prints the following message to the screen:
\begin{verbatim}
    How would you like to die?
    1) electrocution
    2) intoxination
    Please enter a number between 1 and 2: 
\end{verbatim} 
If the user would now presses the digit 1 and hits the enter key, then the function \texttt{ask} will
return the string \texttt{"electrocution"}.

\subsection{\texttt{deleteFile}}
The function \texttt{deleteFile} is called as
\\[0.2cm]
\hspace*{1.3cm}
$\mathtt{deleteFile}(\textsl{fileName})$.
\\[0.2cm]
Here, \textsl{fileName} is a string denoting the name of a file.
If a file with the specified name does exist, it is deleted.  In this case the function
returns \texttt{true}.  If a file with the specified name does not exist, the function
returns \texttt{false} instead.

\subsection{\texttt{get}}
The function \texttt{get}  is called as
\\[0.2cm]
\hspace*{1.3cm}
$\mathtt{get}(s)$.
\\[0.2cm]
Here, $s$ is a string that is used for a prompt. This argument is optional.  The function prints $s$ and then
returns the string that the user has supplied.  If no string is supplied, \texttt{get}
uses the prompt \texttt{": "}.

\subsection{\texttt{load}}
The function \texttt{load}  is called as
\\[0.2cm]
\hspace*{1.3cm}
$\mathtt{load}(\textsl{file})$.
\\[0.2cm]
Here, \textsl{file} has to be a string that denotes a file name, including  the extension
of the file.  Furthermore, \textsl{file} is expected to contain valid \setlx\ commands.
These commands are then executed.  In general, most of the commands will be definitions of
functions.  These function can then be used interactively.

\subsection{\texttt{loadLibrary}}
The function \texttt{loadLibrary}  is called as
\\[0.2cm]
\hspace*{1.3cm}
$\mathtt{loadLibrary}(\textsl{file})$.
\\[0.2cm]
Here, \textsl{file} has to be a string that denotes a file name, \underline{excludin}g the extension
of the file.  This file is assumed to be located in the directory that is specified by the
environment variable 
\\[0.2cm]
\hspace*{1.3cm}
\texttt{SETLX\_LIBRARY\_PATH}.
\\[0.2cm]
There are three different ways to set this variable.
\begin{enumerate}
\item The variable can be  set a in file like ``\texttt{.profile}'' or
      ``\texttt{.bashrc}'', or something similar.  Depending on the type of shell you are
      using, these files are automatically executed when a new shell is started.
\item The variable can be set manually in the shell.
\item The variable can be set using the option ``\texttt{--libraryPath}''.
\end{enumerate}
The specified \textsl{file} is expected to contain valid \setlx\ commands.

\subsection{\texttt{multiLineMode}}
The function \texttt{multiLineMode}  is called as
\\[0.2cm]
\hspace*{1.3cm}
$\mathtt{multiLineMode}(\textsl{flag})$.
\\[0.2cm]
Here, \texttt{flag} should be an expression that evaluates to a  Boolean value.  The
function either activates or deactivates \emph{multi line mode}.  If multi line mode is
activated, then in a shell the next input expression is only evaluated after  the user
hits the return key twice.  Multi line mode makes it possible to enter statements spanning
several lines interactively.  However, normally this mode is inconvenient, as it requires
the user to press the return key twice in order to evaluate an expression.  Therefore, by
default multi line mode is not active.  Multi line mode can also be activated using the option 
``\texttt{--multiLineMode}'' when starting \setlx.

\subsection{\texttt{nPrint}}
The function \texttt{nPrint}  is called as
\\[0.2cm]
\hspace*{1.3cm}
$\mathtt{nPrint}(a_1, \cdots, a_n)$.
\\[0.2cm]
It takes any number of arguments and prints these arguments onto the standard output
stream.  In contrast to the function
\texttt{print}, this function does not append a newline to the printed output.

\subsection{\texttt{nPrintErr}}
The function \texttt{nPrintErr}  is called as
\\[0.2cm]
\hspace*{1.3cm}
$\mathtt{nPrintErr}(a_1, \cdots, a_n)$.
\\[0.2cm]
It takes any number of arguments and prints these arguments onto the standard error
stream.  In contrast to the function
\texttt{printErr}, this function does not append a newline to the printed output.

\subsection{\texttt{print}}
The function \texttt{print}  is called as
\\[0.2cm]
\hspace*{1.3cm}
$\mathtt{print}(a_1, \cdots, a_n)$.
\\[0.2cm]
It takes any number of arguments and prints these arguments onto the standard output
stream. After all arguments are
printed, this function appends a newline to the output.

\subsection{\texttt{printErr}}
The function \texttt{printErr}  is called as
\\[0.2cm]
\hspace*{1.3cm}
$\mathtt{printErr}(a_1, \cdots, a_n)$.
\\[0.2cm]
It takes any number of arguments and prints these arguments onto the standard error
stream.  After all arguments are
printed, this function appends a newline to the output.

\subsection{\texttt{read}}
The function \texttt{read}  is called as
\\[0.2cm]
\hspace*{1.3cm}
$\mathtt{read}(s)$.
\\[0.2cm]
Here, $s$ is a string that is used for a prompt.  This argument is optional. The function
prints $s$ and then 
returns the string that the user has supplied.  However, leading and trailing white space 
is removed from the string that has been read.  If the string can be interpreted as a
number, this number is returned instead.  Furthermore, this function keeps prompting the
user for input until the user enters a non-empty string.

\subsection{\texttt{readFile}}
The function \texttt{readFile}  is called as
\\[0.2cm]
\hspace*{1.3cm}
$\mathtt{readFile}(\textsl{file}, \textsl{lines})$.
\\[0.2cm]
The second parameter \textsl{lines} is optional.
It reads the specified file and returns a list of strings.  Each string corresponds to one
line of the file.   This second parameter \textsl{lines} specifies the list of line
numbers to read.  For example,  the statement 
\\[0.2cm]
\hspace*{1.3cm}
\texttt{read("file.txt",[42] + [78..113])}
\\[0.2cm]
will read line number 42 and the lines 78 up to and including line 113 of the given file.
This feature can be used to read a file in chunks of 1000 lines as in the following example:
\begin{verbatim}
    n := 1;
    while (true) {
        content := readFile("file", [n .. n + 999]);
        if (content != []) {
            // process 1k lines
            ....
            n += 1000;
        } else {
            break;
        }
    }
\end{verbatim}

\subsection{\texttt{writeFile}}
The function \texttt{writeFile}  is called as
\\[0.2cm]
\hspace*{1.3cm}
$\mathtt{writeFile}(f, l)$.
\\[0.2cm]
Here, $f$ is the name of the file and $l$ is a list.  The file $f$ is created and the list
$l$ is written into the file $f$.  The different elements of $l$ are separated by newlines.


\section{Plotting Functions}
This section lists all plotting functions, specifies their parameters and provide small examples
that demonstrate the use of these functions.
 

\subsection{plot\_createCanvas} 
The function \texttt{plot\_createCanvas} returns a canvas object that can be used for plotting.
All other plotting functions need a canvas object as their first argument.  In general, it is
possible to plot multiple graphs on a canvas object.  However, it is not possible to plot both
functions and charts onto a canvas.  Hence, a canvas can either hold function graphs and scatter
plots or it can hold statistical charts.

The function \texttt{plot\_createCanvas} takes one parameter.  This parameter is a string that adds
a title to the canvas. This parameter is optional.  The function returns a canvas object.

\paragraph{Example Code}
\begin{verbatim}
    c := plot_createCanvas();
    c := plot_createCanvas("Canvas Name");
\end{verbatim}

\subsection{plot\_addBullets} 
This function adds points into a canvas.  Currently, these points are represented as squares.
The function \texttt{plot\_addBullets} is called as follows:
\\[0.2cm]
\hspace*{1.3cm}
\texttt{plot\_addBullets}(\textsl{canvas}, \textsl{coordinates}, \textsl{color}, \textsl{size})
\\[0.2cm]
The parameters are interpreted as follows:
\begin{enumerate}
 \item \textsl{canvas} is a canvas object that has been previously created using the function
       \texttt{plot\_createCanvas}.  
\item \textsl{coordinates} is a list of pairs of floating point numbers.  Hence, these pairs have
       the form $[x, y]$.  Here $x$ specifies the x-coordinate of the point to be plotted, while 
       $y$ specifies its y-coordinate.
\item \texttt{color} is a list of three integers of the form $[r,g,b]$, where $r$, $g$, and $b$ are
      elements of the set $\{1, \cdots, 255\}$ that together specify the color of the points
      to be plotted in the \href{https://en.wikipedia.org/wiki/RGB_color_model}{RGB color model}.

      This parameter is optional and defaults to \texttt{[0,0,0]} which is the RGB code for the
      color black.
\item \textsl{size} is a floating point value that specifies the size of the bullet.  
      This parameter is optional.
\end{enumerate}
The function returns a reference to the points that have been created.  This reference can be used
to remove the points from the canvas via the function \texttt{plot\_removeGraph}, which is discussed
later. 

\paragraph{Example Code}
\begin{verbatim}
    c  := plot_createCanvas();
    b1 := plot_addBullets(c, [[0,0]]);                     // one bullet
    b2 := plot_addBullets(c, [[1,1], [2,2], [3,3]]);       // three bullets
    b3 := plot_addBullets(c, [[1,2]], [255, 0, 0]);        // one red bullet
    b4 := plot_addBullets(c, [[1,2]], [0, 255, 0], 10.0);  // one bigger bullet
\end{verbatim}


\subsection{plot\_addGraph}
The function \texttt{plot\_addGraph} plots the graph of a function.
The function \texttt{plot\_addGraph} is called as follows:
\\[0.2cm]
\hspace*{1.3cm}
\texttt{plot\_addGraph}(\textsl{canvas}, \textsl{function}, \textsl{label}, \textsl{color}, \textsl{fill})
\\[0.2cm]
The parameters are interpreted as follows:
\begin{enumerate}
 \item \textsl{canvas} is a canvas object that has been previously created using the function
       \texttt{plot\_createCanvas}.  
\item \textsl{function} is a string that specifies the function that is to be plotted.
      This string uses the letter ``\texttt{x}'' to specify the independent variable.
      For example, in order to draw the function $x \mapsto x \cdot x$ we could use the string
      string ``\texttt{x*x}''
\item \textsl{label} is a string that is used to label the function in the legend that is drawn at
      the bottom of the generated figure.
\item \texttt{color} is a list of three integers of the form $[r,g,b]$, where $r$, $g$, and $b$ are
      elements of the set $\{1, \cdots, 255\}$ that together specify the color of the points
      to be plotted in the \href{https://en.wikipedia.org/wiki/RGB_color_model}{RGB color model}.

      This parameter is optional and defaults to \texttt{[0,0,0]} which is the RGB code for the
      color black.
\item \textsl{fill} is a boolean parameter that specifies whether the area under the graph should be
      colored as well.  

      This parameter is optional and defaults to \texttt{false}.  Hence, if this
      parameter is not used then only the graph of the function is drawn.
\end{enumerate}
The function returns a reference to the graph that has been created.  This reference can be used
to remove the graph from the canvas.
 
\paragraph{Example Code}
\begin{verbatim}
    c  := plot_createCanvas();
    g1 := plot_addGraph(c, "x*x", "parabola");
    g2 := plot_addGraph(c, "x**3", "cubic function in red", [255, 0, 0]);
    g3 := plot_addGraph(c, "sin(x)", "area under the sine", [0, 0, 0], true);
\end{verbatim}


\subsection{plot\_addListGraph}
The function \texttt{plot\_addListGraph} takes a list of points and connects these points via straight lines.
This function is called as follows:
\\[0.2cm]
\hspace*{1.3cm}
\texttt{plot\_addListGraph}(\textsl{canvas}, \textsl{coordinates}, \textsl{label}, \textsl{color}, \textsl{fill})
\\[0.2cm]
The parameters are interpreted as follows:
\begin{enumerate}
 \item \textsl{canvas} is a canvas object that has been previously created using the function
       \texttt{plot\_createCanvas}.  
\item \textsl{coordinates} is a list of pairs of floating point numbers.  Hence, these pairs have
       the form $[x, y]$.  Here $x$ specifies the x-coordinate of a point, while 
       $y$ specifies its y-coordinate.  The points specified via \textsl{coordinates} are connected
       via straight lines.
\item \textsl{label} is a string that is used to label the graph in the legend that is drawn at
      the bottom of the generated figure.
\item \texttt{color} is a list of three integers of the form $[r,g,b]$, where $r$, $g$, and $b$ are
      elements of the set $\{1, \cdots, 255\}$ that together specify the color of the points
      to be plotted in the \href{https://en.wikipedia.org/wiki/RGB_color_model}{RGB color model}.

      This parameter is optional and defaults to \texttt{[0,0,0]} which is the RGB code for the
      color black.
\item \textsl{fill} is a boolean parameter that specifies whether the area under the lines should be
      colored as well.  

      This parameter is optional and defaults to \texttt{false}.  Hence, if this
      parameter is not used then only the lines connecting the points are drawn.
\end{enumerate}

\paragraph{Example Code}
\begin{verbatim}
    c  := plot_createCanvas();
    g1 := plot_addListGraph(c, [[10, 0],[-10,0]], "simple List graph");
    g2 := plot_addListGraph(c, [[-10, -10], [-5, -5], [0, 1], [5,6]], 
                            "listgraph with color", [255, 0, 0]);
    g2 := plot_addListGraph(c, [[-10, 10], [-5, 5], [0, 0], [2.5,6], [5, -4]], 
                            "listgraph with color and area", [255, 0, 255], true);
\end{verbatim}

\subsection{plot\_addParamGraph}
The function \texttt{plot\_addParamGraph} plots a parametric curve.  The function is called as
follows:
\\[0.2cm]
\hspace*{1.3cm}
\texttt{plot\_addParamGraph}(\textsl{canvas}, \textsl{x-fct}, \textsl{y-fct}, \textsl{label}, \textsl{limits}, \textsl{color}, \textsl{fill})
\\[0.2cm]
The parameters are interpreted as follows:
\begin{enumerate}
\item \textsl{canvas} is a canvas object that has been previously created using the function
       \texttt{plot\_createCanvas}.  
\item \textsl{x-fct} is a string that specifies how the x-coordinate is to be computed.
      This string uses the letter ``\texttt{x}'' to specify the parameter.
\item \textsl{y-fct} is a string that specifies how the y-coordinate is to be computed.
      Again, this string uses the letter ``\texttt{x}'' to specify the parameter.
\item \textsl{label} is a string that is used to label the function in the legend that is drawn at
      the bottom of the generated figure.
\item \textsl{limits} is a pair of two floating point numbers.  This pair has the form
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{[} \textsl{xMin}, \textsl{xMax}\texttt{]}.
      \\[0.2cm]
      Here, \textsl{xMin} is the smallest value of the parameter ``\texttt{x}'' that is used, while
      \textsl{xMax} specifies the biggest value.
\item \texttt{color} is a list of three integers of the form $[r,g,b]$, where $r$, $g$, and $b$ are
      elements of the set $\{1, \cdots, 255\}$ that together specify the color of the points
      to be plotted in the \href{https://en.wikipedia.org/wiki/RGB_color_model}{RGB color model}.

      This parameter is optional and defaults to \texttt{[0,0,0]} which is the RGB code for the
      color black.
\item \textsl{fill} is a boolean parameter that specifies whether the area between the graph and the
      x-axis should be colored as well.  

      This parameter is optional and defaults to \texttt{false}.  Hence, if this
      parameter is not used then only the graph of the function is drawn.
\end{enumerate}
The function returns a reference to the graph that has been created.  This reference can be used
to remove the graph from the canvas.

\paragraph{Example Code}
\begin{verbatim}
    c  := plot_createCanvas();
    g1 := plot_addParamGraph(c, "3*cos(x)", "3*sin(x)", 
                             "circle with radius 3", 
                             [-3.15, 3.15]);
    g2 := plot_addParamGraph(c, "2*cos(x)", "2*sin(x)", 
                             "colored circle with radius 2", 
                             [-3.15, 3.15], [0, 255, 0]);
    g3 := plot_addParamGraph(c, "cos(x)", "sin(x)", 
                             "filled green circle", 
                             [-3.15, 3.15], [0, 255, 0], true);
\end{verbatim}


\subsection{plot\_addBarChart}
The function \texttt{plot\_addBarChart} creates a bar chart where the bars are drawn vertically.
This function is called as follows:
\\[0.2cm]
\hspace*{1.3cm}
\texttt{plot\_addBarChart}(\textsl{canvas}, \textsl{values}, \textsl{labels}, \textsl{name})
\\[0.2cm]
The parameters are interpreted as follows:
\begin{enumerate}
\item \textsl{canvas} is a canvas object that has been previously created using the function
      \texttt{plot\_createCanvas}.  
\item \textsl{values} is a list of floating point numbers. These numbers specify the height of the
      bars.
\item \textsl{labels} is a list of strings.  This list has to have the same length as the list
      \textsl{values}.  The strings in the list \textsl{labels} are uses as legends at the bottowm
      of the bar chart.  For example, in Figure \ref{fig:world-population.eps} on page
      \pageref{fig:world-population.eps} the list that is used as labels has the form
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{[\qote{Northern America}, \qote{Oceania}, \qote{Latin America}, \qote{Europe}, \qote{Africa}, \\
        \hspace*{1.3cm} 
        \qote{Asia}, \qote{World}]}
\item \textsl{name} is a string that attaches a common name to all values given in the list
      \textsl{value}.  This parameter is used in the legend of the bar chart.  
\item Note that there is no parameter to set the color of the individual bars.  All bars resulting
      from the same invocation of a call of the function \texttt{plot\_addBarChart} are filled with
      the same color, while \setlx\ uses different colors for different invocation of
      \texttt{plot\_addBarChart}.  For example, in order to generate Figure
      \ref{fig:world-population.eps} on page \pageref{fig:world-population.eps} the function 
      \texttt{plot\_addBarChart} was called five times: The first invocation created the red bars
      corresponding to the year 1900, the second invocation created the blue bars showing the
      population in 1950 and so on.
\end{enumerate}
The function returns a reference to the graph that has been created.  This reference can be used
to remove the graph from the canvas.

\paragraph{Example Code}
\begin{verbatim}
    c   := plot_createCanvas();
    ch1 := plot_addBarChart(c, [1,2], ["a","b"], "data set number 1");
    ch2 := plot_addBarChart(c, [2,1], ["a","b"], "data set number 2");
\end{verbatim}

\subsection{plot\_addPieChart}
The function \texttt{plot\_addPieChart} creates a pie chart.
This function is called as follows:
\\[0.2cm]
\hspace*{1.3cm}
\texttt{plot\_addPieChart}(\textsl{canvas}, \textsl{values}, \textsl{labels})
\\[0.2cm]
The parameters are interpreted as follows:
\begin{enumerate}
\item \textsl{canvas} is a canvas object that has been previously created using the function
      \texttt{plot\_createCanvas}.  
\item \textsl{values} is a list of floating point numbers. These numbers specify the area of the
      pies associated with them.
\item \textsl{labels} is a list of strings.  This list has to have the same length as the list
      \textsl{values}.  The strings in the list \textsl{labels} are used as legends for the pie chart.
      For example, in the first pie chart shown in Figure \ref{fig:race-prison} on page
      \pageref{fig:race-prison} the list that is used as labels has the form
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{[\qote{white}, \qote{black}, \qote{latino}, \qote{other}]}.
\item Note that there is no parameter to set the color of the individual pies.  
      These colors are chosen automatically by \setlx.
\end{enumerate}
The function returns a reference to the pie chart that has been created.  This reference can be used
to remove this chart from the canvas.

\paragraph{Example Code}
\begin{verbatim}
    c  := plot_createCanvas();
    ch := plot_addPieChart(c, [1,2,3,4], ["a","b","c","d"]);
\end{verbatim}


\subsection{plot\_addLabel}
The function \texttt{plot\_addLabel} takes a canvas and adds a label at a specified position.  This
function is called as
\\[0.2cm]
\hspace*{1.3cm}
\texttt{plot\_addLabel}(\textsl{canvas}, \textsl{coordinate}, \textsl{label})
\\[0.2cm]
The parameters are interpreted as follows:
\begin{enumerate}
\item \textsl{canvas} specifies the canvas where the label needs to be added.
\item \textsl{coordinates} is a pair of floating point numbers.  Hence, this pair has
       the form $[x, y]$.  Here $x$ specifies the x-coordinate of a point, while 
       $y$ specifies its y-coordinate.  These coordinates specify the location of the
       \textsl{label}.  Specifically, the pair $[x,y]$ specifies the position of the lower left
       corner of the label. 
\item \textsl{label} is a string that is printed on the canvas at the position specified via the
      parameter \textsl{coordinates}. 
\end{enumerate}
The function \texttt{plot\_addLabel} returns a reference to the label that has been created.  This
reference can be used to remove the label using the function \texttt{plot\_removeGraph} discussed below.
\paragraph{Example Code}
\begin{verbatim}
    c := plot_createCanvas();
    g := plot_addGraph(c, "x*x", "parabola");
    l := plot_addLabel(c, [0,0], "origin");
\end{verbatim}

\subsection{plot\_defineTitle}
The function \texttt{plot\_defineTitle} takes a canvas and adds a title to the graph.  Note that the
title is added below the title that is set with \texttt{plot\_createCanvas}.  
The function \texttt{plot\_createCanvas} is called as follows:
\\[0.2cm]
\hspace*{1.3cm}
\texttt{plot\_createCanvas}(\textsl{canvas}, \textsl{title})
\\[0.2cm]
The parameters are interpreted as follows:
\begin{enumerate}
\item \textsl{canvas} specifies the canvas.
\item \textsl{title} is the string that is used as title.
\end{enumerate}
This function does not return a value. 

\paragraph{Example Code}
\begin{verbatim}
    c := plot_createCanvas();
    plot_defineTitle(c, "Title of Canvas");
\end{verbatim}

\subsection{plot\_exportCanvas}
The function \texttt{plot\_exportCanvas} stores a canvas on disk as a file in the
\href{https://en.wikipedia.org/wiki/Portable_Network_Graphics}{PNG} format.
The function is called as follows:
\\[0.2cm]
\hspace*{1.3cm}
\texttt{plot\_exportCanvas}(\textsl{canvas}, \textsl{fileName})
\\[0.2cm]
The parameters are interpreted as follows:
\begin{enumerate}
\item \textsl{canvas} is the canvas that is to be saved to disk.
\item \textsl{fileName} is a string that specifies the name of the file that is used to store the
      image of the canvas.  Note that the file extension ``\texttt{.png}'' is automatically added to
      \textsl{fileName} when the file is stored on disk.
\end{enumerate}
The function does not return a value.

\paragraph{Example Code}
\begin{verbatim}
    c := plot_createCanvas();
    plot_addGraph(c, "cos(x)", "the cosine function");
    plot_exportCanvas(c, "cosine");
\end{verbatim}


\subsection{plot\_labelAxis}
The function \texttt{plot\_labelAxis} changes the labels of both x-axis and y-axis.  The function is
called as follows:
\\[0.2cm]
\hspace*{1.3cm}
\texttt{plot\_labelAxis}(\textsl{canvas}, \textsl{xLabel}, \textsl{yLabel})
\\[0.2cm]
The parameters are interpreted as follows: 
\begin{enumerate}
\item \textsl{canvas} specifies the canvas whose axis are to be modified.
\item \textsl{xLabel} is a string that is used as the new label of the x-axis.
      If this string is the empty string, then the label of the x-axis is removed.
\item \textsl{yLabel} is a string that is used as the new label of the y-axis.
      If this string is the empty string, then the label of the y-axis is removed.
\end{enumerate}
This function does not return a value.

\paragraph{Example Code}
\begin{verbatim}
    c := plot_createCanvas();
    plot_addGraph(c, "x*x", "parabola");
    plot_labelAxis(c, "x-axis", "y-axis");
\end{verbatim}

\subsection{plot\_legendVisible}
The function \texttt{plot\_legendVisible} shows or hides the legend of a graph.
The function is called  as follows:
\\[0.2cm]
\hspace*{1.3cm}
\texttt{plot\_legendVisible}(\textsl{canvas}, \textsl{flag})
\\[0.2cm]
The parameters are interpreted as follows:
\begin{enumerate}
\item \textsl{canvas} specifies the canvas whose legends are to be shown or hidden.
\item \textsl{flag} is a Boolean value.  If \textsl{flag} is \texttt{true}, the legend is shown.
      If \textsl{flag} is \texttt{false} the legend is hidden instead.  
\end{enumerate}
By default, the legend of a canvas is visible.  In order to switch the legend off, the function
\texttt{plot\_legendVisible} has to be called with its second parameter set to \texttt{false}.

\paragraph{Example Code}
\begin{verbatim}
    c := plot_createCanvas();
    plot_addGraph(c, "x*x-2", "parabola");
    plot_legendVisible(c, false);
\end{verbatim}

\subsection{plot\_modScale}
The function \texttt{plot\_modScale} changes the scale of both the x-axis and the y-axis.
Of course, this function can only be called for those graphs that have an x-axis and a y-axis.
Hence, this function cannot be called for pie charts or bar charts.
The function is called as follows:
\\[0.2cm]
\hspace*{1.3cm}
\texttt{plot\_modScale}(\textsl{canvas}, \textsl{xLimits}, \textsl{yLimits})
\\[0.2cm]
The parameters are interpreted as follows:
\begin{enumerate}
\item \textsl{canvas} specifies the canvas whose axis are to be changed.
\item \textsl{xLimits} is pair of floating point numbers, i.e.~\textsl{xLimits} has the form
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{[}\textsl{xMin}, \textsl{xMax}\texttt{]}.
      \\[0.2cm]
      Here, \textsl{xMin} is the smallest value shown on the x-axis, while \textsl{xMax} is the
      largest value.
\item \textsl{yLimits} is pair of floating point numbers, i.e.~\textsl{yLimits} has the form
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{[}\textsl{yMin}, \textsl{yMax}\texttt{]}.
      \\[0.2cm]
      Here, \textsl{yMin} is the smallest value shown on the y-axis, while \textsl{yMax} is the
      largest value.
\end{enumerate}
This function does not return a value.

\paragraph{Example Code}
\begin{verbatim}
    c := plot_createCanvas();
    plot_addGraph(c, "x**2-2*x", "parabola");
    plot_modScale(c, [0, 5], [-2, 16]);
\end{verbatim}

\subsection{plot\_modScaleType}
The function \texttt{plot\_modScaleType} changes the scaling type of an axis.  An axis can either be
scaled linearly or logarithmically.  If an axis is scaled linearly, then the distance between any two
numbers on the axis is proportionally to the difference of these numbers.  On the other hand, if an
axis is scaled logarithmically, then the distance between any two numbers on the axis is
proportionally to the quotient of these numbers.  The function \texttt{plot\_modScaleType} is called
as follows:
\\[0.2cm]
\hspace*{1.3cm}
\texttt{plot\_modScaleType}(\textsl{canvas}, \textsl{xType}, \textsl{yType})
\\[0.2cm]
The parameters are interpreted as follows:
\begin{enumerate}
\item \textsl{canvas} specifies the canvas that is to be changed.
\item \textsl{xType} is a string that is a member of the set $\{ \mathtt{\symbol{34}num\symbol{34}}, \mathtt{\symbol{34}log\symbol{34}} \}$.
      If \textsl{xType} is equal to the string \texttt{\symbol{34}num\symbol{34}}, then the x-axis
      is scaled linearly. If \textsl{xType} is equal to the string \texttt{\symbol{34}log\symbol{34}}, then the x-axis
      is scaled logarithmically.
\item \textsl{yType} is a string that is a member of the set $\{ \mathtt{\symbol{34}num\symbol{34}}, \mathtt{\symbol{34}log\symbol{34}} \}$.
      If \textsl{yType} is equal to the string \texttt{\symbol{34}num\symbol{34}}, then the y-axis
      is scaled linearly. If \textsl{yType} is equal to the string \texttt{\symbol{34}log\symbol{34}}, then the y-axis
      is scaled logarithmically.
\end{enumerate}
The function does not return a value.

\paragraph{Example Code}
\begin{verbatim}
    c := plot_createCanvas();
    plot_addGraph(c, "x**2-2*x", "parabola");
    plot_modScaleType(c, "num", "log");
\end{verbatim}

\subsection{plot\_removeGraph}
The function \texttt{plot\_removeGraph} removes a graph or a chart from a canvas.
The function is called as follows:
\\[0.2cm]
\hspace*{1.3cm}
\texttt{plot\_removeGraph}(\textsl{canvas}, \textsl{reference})
\\[0.2cm]
The parameters are interpreted as follows:
\begin{enumerate}
\item \textsl{canvas} specifies the canvas from which a graph or chart is to be removed.
\item \textsl{reference} is a reference to the graph or canvas that is to be removed.
      This reference is the return value of any of the \texttt{plot\_add*} functions.
\end{enumerate}
This function does not return a value.

\paragraph{Example Code}
\begin{verbatim}
    c  := plot_createCanvas();
    g1 := plot_addGraph(c, "sin(x)", "sine");
    g2 := plot_addListGraph(c, [[-1, 1], [-2, 0], [1, 3], [2, 1]], "lines");
    g3 := plot_addParamGraph(c, "cos(x)", "sin(x)", "circle", [-5,5]);
    l1 := plot_addLabel(c, [1,1], "some text");
    b1 := plot_addBullets(c, [[1, 2]]);
    plot_removeGraph(c, g3);
    plot_removeGraph(c, g2);
    plot_removeGraph(c, g1);
    plot_removeGraph(c, l1);
    plot_removeGraph(c, b1);
\end{verbatim}



\subsection{plot\_modSize}
The function \texttt{plot\_modSize} changes the size of the canvas.  The function is called as follows:
\\[0.2cm]
\hspace*{1.3cm}
\texttt{plot\_modSize}(\textsl{canvas}, \textsl{size})
\\[0.2cm]
The parameters are interpreted as follows:
\begin{enumerate}
\item \textsl{canvas} specifies the canvas whose size is to be changed.
\item \textsl{size} is a pair of natural numbers.  This pair has the form
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{[}\textsl{width}, \textsl{height} \texttt{]}.
      \\[0.2cm]
      Here, \textsl{width} specifies the new width of the canvas area in pixles, while
      \textsl{height} specifies the height of the window.
\end{enumerate}
The function does not return a value.

\paragraph{Example Code}
\begin{verbatim}
    c := plot_createCanvas();
    plot_modSize(c, [1024,768]);
    plot_addParamGraph(c, "sin(x)", "cos(x)", "circle", [-3.15, 3.15]);
\end{verbatim}



\section{Miscellaneous Functions}
This final section lists some functions that did not fit into any of the other sections.


\subsection{\texttt{\texttt}{abort}}
This function aborts the execution of the current function.  This is done by raising an
exception.  Usually, the function \texttt{abort} is called with one argument.  This
argument is then thrown as an exception.  For example, the statement
\\[0.2cm]
\hspace*{1.3cm}
\texttt{try \{ abort(1); \} catch (e) \{ print("e = \$e\$"); \}}
\\[0.2cm]
will print the result
\\[0.2cm]
\hspace*{1.3cm}
\texttt{e = Error: abort: 1}.
\\[0.2cm]
Note that an exception raised via \texttt{abort} can not be catched with the keyword
\texttt{catchUsr}.   The keyword \texttt{catchUsr} will only catch exceptions that are
explicitly thrown by the user via invocation of \texttt{throw}.

\subsection{\texttt{cacheStats}}
The function \texttt{cacheStats}  is called as
\\[0.2cm]
\hspace*{1.3cm}
$\mathtt{cacheStats}(f)$.
\\[0.2cm]
Here, $f$ is a cached procedure, i.e.~a procedure that is declared using the
keyword ``\texttt{cachedProcedure}''.  Note that $f$ has to be the procedure itself, not
the name of the procedure!  The returned result is a set of the form
\\[0.2cm]
\hspace*{1.3cm}
\texttt{\{["cache hits", 996], ["cached items", 1281]\}}.
\\[0.2cm]
This set can be interpreted as a map.  

\subsection{\texttt{clearCache}}
The function \texttt{clearCache}  is called as
\\[0.2cm]
\hspace*{1.3cm}
$\mathtt{clearCache}(f)$.
\\[0.2cm]
Here, $f$ is a cached procedure, i.e.~a procedure that is declared using the
keyword ``\texttt{cachedProcedure}''.  Note that $f$ has to be the procedure itself, not
the name of the procedure!  The invocation of $\texttt{clearCache}(f)$ frees the memory
associated with the cache for the function $f$.  It should be used if the previously
computed values of $f$ are not likely to be needed for the next computation.

\subsection{\texttt{compare}}
The function \texttt{compare}  is called as
\\[0.2cm]
\hspace*{1.3cm}
$\mathtt{compare}(x, y)$.
\\[0.2cm]
Here, $x$ and $y$ are two arbitrary values.  This function returns $-1$ if $x$ is less
than $y$, $+1$ if $x$ is bigger than $y$ and $0$ if $x$ and $y$ are equal.
If $x$ and $y$ have a numerical type,  then the result of $\mathtt{compare}(x,y)$
coincides with the result produced by the operator ``\texttt{<}''.
If $x$ and $y$ are both lists, then the lists are compared lexicographically.
The same remark holds if $x$ and $y$ are both sets.   If $x$ and $y$ have different types,
then the result of $\mathtt{compare}(x, y)$ is implementation defined.  Therefore, the
user should not rely on the results returned in these cases.

The function \texttt{compare} is needed internally in order to compare the elements of a
set.  In \setlx\ all sets are represented as ordered binary trees.

\subsection{\texttt{getOsID}}
The function \texttt{getOsID} returns an identifier for the operating system that setlX runs on.

\subsection{\texttt{getScope}}
The function \texttt{getScope}  is called as
\\[0.2cm]
\hspace*{1.3cm}
$\mathtt{getScope}()$.
\\[0.2cm]
It returns a term representing the  \emph{current scope}.  Here, the current scope
captures the binding of all variables.  For example, suppose the user issues the following
commands: 
\begin{verbatim}
    x := 1;
    y := 2;
    f := procedure(n) { return n * n; };
\end{verbatim}
Then the current scope consists of the variables \texttt{x}, \texttt{y}, and \texttt{f}.
Therefore, in this case the expression \texttt{getScope()} returns the following term:
\begin{verbatim}
^scope({["f", procedure(n) { return n * n; }], 
        ["getScope", ^preDefinedProcedure("getScope")], ["params", []], 
        ["x", 1], 
        ["y", 2]
       })
\end{verbatim}
 
\subsection{\texttt{logo}}
The function \texttt{logo}  is called as
\\[0.2cm]
\hspace*{1.3cm}
$\mathtt{logo}()$.
\\[0.2cm]
In order to find how this function works, try it yourself.

\subsection{\texttt{now}}
The function \texttt{now}  returns the number of milliseconds that have elapsed since
the beginning of the Unix epoch.

\subsection{\texttt{run}}
The function \texttt{run} executes a shell command, i.e.~a command that would otherwise be
invoked via a shell like \texttt{bash} or the windows command line.  The function \texttt{run(\textsl{cmd})} returns a pair
of lists: The first list contains the strings that make up the output produced when running the
command  \texttt{\textsl{cmd}} in the command line.  Every string in the list corresponds to one line
of output produced by  \texttt{\textsl{cmd}}. 
 The second list is empty as long as   \texttt{\textsl{cmd}} does not produce any error messages.
 If there are error messages, these are collected in the second list returned as the result of   \texttt{run(\textsl{cmd})}.
For example, the command
\\[0.2cm]
\hspace*{1.3cm}
\texttt{run('ls *.tex');}
\\[0.2cm]
yields the output
\\[0.2cm]
\hspace*{1.3cm}
\texttt{[["backtracking.tex", "basics.tex", "closures.tex"], []]}
\\[0.2cm]
in one of my directories containing \TeX files.  However, if this command is executed in a
directory that does not contain any file with the extension ``\texttt{.tex}'', then the output is
\\[0.2cm]
\hspace*{1.3cm}
\texttt{[[], ["ls: *.tex: No such file or directory"]]}
\\[0.2cm]
indicating that there are no files matching the pattern ``\texttt{*.tex}''.

\subsection{\texttt{\ sleep}}
The function sleep takes one argument that has to be a positive natural number.  The expression
\\[0.2cm]
\hspace*{1.3cm}
$\texttt{sleep}(t)$
\\[0.2cm]
pauses the execution of the process running \setlx\ for $t$ milliseconds.  When printing
output, this can be used for visual effects.


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "tutorial"
%%% End: 
