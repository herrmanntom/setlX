\chapter{Whetting Your Appetite}
This chapter contains a short overview of the data types supported by
\setlx\ and tries to whet your appetite for the language by showing off some of
the features that are unique to \setlx.  Before we discuss the more elaborate data types,
we introduce the basic data types for numbers and strings and show how to invoke the interpreter.


\section{Getting Started}
\setlx\ is an interpreted language.  To start the interpreter,  the file
\texttt{setlX} has to be both executable and part of the search path.   If these
preconditions are satisfied, the command
\\[0.2cm]
\hspace*{1.3cm}
\texttt{setlX}
\\[0.2cm]
 launches the interpreter.  The interpreter first prints the banner shown in Figure
\ref{fig:banner}, followed by a prompt``\texttt{=>}''.  Commands are typed after the prompt.    
If the command is an assignment or an expression, then it has to be terminated by a semicolon.
However, complex commands like, for example, branch statements, loops or class definitions are not
terminated by a semicolon. 

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = none,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
-====================================setlX=============================v2.7.0=-

Welcome to the setlX interpreter!

Open Source Software from http://setlX.randoom.org/
(c) 2011-2017 by Herrmann, Tom

You can display some helpful information by using '--help' as parameter when
launching this program.

Interactive-Mode:
  The 'exit;' statement terminates the interpreter.

-===============================Interactive=Mode==============================-

=>
\end{Verbatim}
\vspace*{-0.3cm}
\caption{The \setlx\ banner followed by a prompt.}
\label{fig:banner}
\end{figure}
\noindent
The welcome banner of \textsc{SetlX} points out that we can call \texttt{setlX} with the parameter 
``\texttt{--help}''.   Doing this yields the output shown in Figure \ref{fig:help-option} below. 

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = none,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
-====================================setlX=============================v2.5.2=-

File paths supplied as parameters for this program will be parsed and executed.
The interactive mode will be started if called without any file parameters.

Interactive-Mode:
  The 'exit;' statement terminates the interpreter.

Additional parameters:
  -l <path>, --libraryPath <path>
      Override SETLX_LIBRARY_PATH environment variable.
  -a, --noAssert
      Disables all assert functions.
  -n, --noExecution
      Load and check code for syntax errors, but do not execute it.
  -r, --predictableRandom
      Always use the same sequence of random numbers (useful for debugging).
  -p <argument> ..., --params <argument> ...
      Pass all following arguments to executed program via `params' variable.
  -e <expression>, --eval <expression>
      Evaluates next argument as expression and exits.
  -x <statement>, --exec <statement>
      Executes next argument as statement and exits.
  -v, --verbose
      Display the parsed program before executing it.
  --doubleDefault
  --doubleScientific
  --doubleEngineering
  --doublePlain
      Sets how the exponent of a floating point number is printed.
  -h, --harshWelcome
      Interactive mode: Reduce welcome message to a bare minimum.
  -m, --multiLineMode
      Interactive mode: Input is only processed after an additional new line.
  --version
      Display interpreter version and terminate.
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Calling \texttt{setlx} with the option ``\texttt{--help}''.}
\label{fig:help-option}
\end{figure}


\noindent
The \setlx\  interpreter can be used as a simple calculator:
Typing 
\\[0.2cm]
\hspace*{1.3cm}
\texttt{\textsl{1/3 + 2/5;}}
\\[0.2cm]
and then hitting the return key\footnote{
In \setlx, statements can extend over many lines.  If the user intends to use multi line
statements, then she can start the interpreter using the commandline switch ``\texttt{--multiLineMode}''.
In multi line mode, the return key needs to be hit twice to signal
the end of the input.  Instead of using a commandline switch, the user can also issue the command
\\
\hspace*{1.3cm}
\texttt{multiLineMode(true);}
\\
to activate multiline mode.
To switch back to single line mode, use the command ``\texttt{multiLineMode(false);}''.
} 
will result in the following response:
\\[0.2cm]
\hspace*{1.3cm}
\texttt{\symbol{126}< Result: 11/15 >\symbol{126}}
\\[0.2cm]
After printing the result, the interpreter provides a new prompt so the next command can
be entered.  Incidently, the last 
example shows the first data type supported by \setlx: Rational numbers. These will be discussed in
more detail next.


\subsection{Rational Numbers and Floating Point Numbers}
\setlx\ supports both rational numbers and floating point numbers.
A rational number consists of a numerator and a denominator, both of which are integers.  \setlx\ takes care to
ensure that numerator and denominator are always reduced to lowest terms.  Furthermore, if the
denominator happens to be the value 1, only the numerator is printed.  Therefore, after typing
\\[0.2cm]
\hspace*{1.3cm}
\texttt{\textsl{1/3 + 2/3;}}
\\[0.2cm]
\setlx\ will respond:
\\[0.2cm]
\hspace*{1.3cm}
\texttt{\symbol{126}< Result: 1 >\symbol{126}}
\\[0.2cm]
The precision of rational numbers is only limited by the available memory.  For example, the command
\\[0.2cm]
\hspace*{1.3cm}
\texttt{50!;}
\\[0.2cm]
computes the factorial of $50$ and yields the result
\\[0.2cm]
\hspace*{0.1cm}
\texttt{\symbol{126}< Result: 30414093201713378043612608166064768844377641568960512000000000000 >\symbol{126}}.
\\[0.2cm]
Therefore, as long as only rational numbers are used, there will be no rounding errors.
Unfortunately, if a rational number $q$ is the result of a computation involving $n$ arithmetic
operations, in the worst case the length of the nominator and denominator of the rational numbers
$q$ grows exponentially with $n$.  For this reason, most calculations in engineering are
done using floating point numbers.  Since \textsc{SetlX} is based on \textsl{Java}, \setlx\ supports
64 bit floating point numbers according to the standard
\href{https://en.wikipedia.org/wiki/IEEE_floating_point}{IEEE 754}. 


\setlx\ provides the following arithmetic operators.  If not stated otherwise, these operators work
for both rational numbers as well as floating point numbers:
\begin{enumerate}
\item ``\texttt{+}'' performs addition.
\item ``\texttt{-}'' performs subtraction.
\item ``\texttt{*}'' performs multiplication.
\item ``\texttt{/}'' performs division.
\item ``\texttt{\symbol{92}}'' performs integer division.
      The result is always an integer.
\item ``\texttt{\%}'' computes the \href{https://en.wikipedia.org/wiki/Remainder}{remainder}.  
      This operator is only provided for rational numbers.

      For rational number $x$ and $y$ the operators ``\texttt{*}'', \texttt{\symbol{92}}'' and ``\texttt{\%}'' 
      satisfy the equation
      \\[0.2cm]
      \hspace*{1.3cm}
      $x = (x \,\texttt{\symbol{92}}\, y) \,\texttt{*}\, y + x\,\texttt{\%}\, y$.
\end{enumerate}
In order to use floating point numbers instead of rational numbers, the easiest way is to add
\texttt{0.0} at the end of an expression because if an arithmetic expression 
contains a floating point value, the result is automatically converted to a floating point number.
Therefore, the expression
\\[0.2cm]
\hspace*{1.3cm}
\texttt{\textsl{1/3 + 2/5 + 0.0;}}
\\[0.2cm]
returns the result:
\\[0.2cm]
\hspace*{1.3cm}
\texttt{\symbol{126}< Result: 0.7333333333333333 >\symbol{126}}
\\[0.2cm]
Of course, the same result can also be achieved via the expression
\\[0.2cm]
\hspace*{1.3cm}
\texttt{1.0/3 + 2/5;}
\\[0.2cm]
Since the precision of rational numbers in \setlx\ is not limited, we can do things like computing
$\sqrt{2}$ to a hundred decimal places.  Figure \ref{fig:sqrt.stlx} on page \pageref{fig:sqrt.stlx}
shows a program that uses the 
\href{http://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method}{\emph{Babylonian method}}
to compute the square root of $2$.  The idea is to compute $\sqrt{2}$ as the limit of the sequence $(b_n)_{n\in\mathbb{N}}$, 
where the numbers $b_n$ are defined by induction on $n$  as follows:
\\[0.2cm]
\hspace*{1.3cm}
$b_1 := 2$ \quad and \quad $\displaystyle b_{n+1} := \frac{1}{2} \cdot \left(b_n + \frac{2}{b_n}\right)$.
\\[0.2cm]
In order to print a rational number in decimal notation with a fixed number of places, the function
$\texttt{nDecimalPlaces}(x,n)$ has been used.  The first argument $x$ is the rational number to be
printed, while the second argument $n$ gives the number of places to be printed.  To run this
program from the command line, assume it is stored in a file with the name \texttt{sqrt.stlx} in the
current directory.  Then the command
\\[0.2cm]
\hspace*{1.3cm}
\texttt{setlX sqrt.stlx}
\\[0.2cm]
loads and executes this program.  Alternatively, the command can be executed interactively in the
interpreter via the following command:
\\[0.2cm]
\hspace*{1.3cm}
\texttt{load(\symbol{34}sqrt.stlx\symbol{34});}
\\[0.2cm]
The output of the program is shown in Figure \ref{fig:sqrt-output}.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    b := 2;
    for (n in [1 .. 9]) {
        b := 1/2 * (b + 2/b);
        print(n + ": " + nDecimalPlaces(b, 100));
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{A program to calculate $\sqrt{2}$ to 100 places.}
\label{fig:sqrt.stlx}
\end{figure}


\begin{figure}[!ht]
\centering
\begin{Verbatim}[ fontsize      = \scriptsize,
                  frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = none,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.5cm,
                  xrightmargin  = 0.5cm,
                ]
1: 1.5000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
2: 1.4166666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666
3: 1.4142156862745098039215686274509803921568627450980392156862745098039215686274509803921568627450980392
4: 1.4142135623746899106262955788901349101165596221157440445849050192000543718353892683589900431576443402
5: 1.4142135623730950488016896235025302436149819257761974284982894986231958242289236217849418367358303565
6: 1.4142135623730950488016887242096980785696718753772340015610131331132652556303399785317871612507104752
7: 1.4142135623730950488016887242096980785696718753769480731766797379907324784621070388503875343276416016
8: 1.4142135623730950488016887242096980785696718753769480731766797379907324784621070388503875343276415727
9: 1.4142135623730950488016887242096980785696718753769480731766797379907324784621070388503875343276415727
\end{Verbatim}
\vspace*{-0.3cm}
\caption{The output produced by the program in Figure \ref{fig:sqrt.stlx}.}
\label{fig:sqrt-output}
\end{figure}

\noindent
The previous program also demonstrates that \setlx\ supports strings.  In \setlx, any sequence of
characters enclosed in either double or single quote characters is a string.  For example, the 
\emph{hello world program} in \setlx\ is just 
\\[0.2cm]
\hspace*{1.3cm}
\texttt{\textsl{\symbol{34}Hello world!\symbol{34};}}
\\[0.2cm]
It yields the output:
\\[0.2cm]
\hspace*{1.3cm}
\texttt{\symbol{126}< Result: "Hello world!" >\symbol{126}}
\texttt{}
\\[0.2cm]
However, this only works in interactive mode.  If you want to be more verbose\footnote{
If you want to be much more verbose, you should program in either \textsl{Cobol} or \textsl{Java}.
} or if you are not working interactively, you can instead write
\\[0.2cm]
\hspace*{1.3cm}
\texttt{\textsl{print(\symbol{34}Hello world!\symbol{34});}}
\\[0.2cm]
This will yield two lines of  output:
\begin{verbatim}
        Hello world!
        ~< Result: om >~
\end{verbatim}
The first line shows the effect of the invocation of the function \texttt{print}, the
second line gives the return value computed by the call of the function $\texttt{print}()$.  As the
function $\texttt{print}()$ does not return a meaningful value, the
return value is the \emph{undefined value} that, following the
tradition of \textsc{Setl}, is denoted as $\Omega$.  In \setlx, this value is written as \texttt{om}.


In order to assign the value of an expression to a variable, \setlx\ provides the 
\emph{assignment operator} ``\texttt{:=}''.  Syntactically, this operator is the only major deviation from the syntax 
of the programming language \texttt{C}. For example, the statement
\\[0.2cm]
\hspace*{1.3cm}
\texttt{x := 1/3;}
\\[0.2cm]
binds the variable \texttt{x} to the fraction \texttt{1/3}.  
\vspace*{0.3cm}


\section{Boolean Values}
The Boolean values \texttt{true} and \texttt{false} represent truth and falsity, respectively.  Boolean
expressions can be constructed using the binary comparison operators ``\texttt{==}'', 
``\texttt{!=}'', ``\texttt{<}'',  ``\texttt{>}'', ``\texttt{<=}'', and ``\texttt{>=}''.
Note that these operators are identical to the comparison operators used in the programming languages
\texttt{C} and \textsl{Java}.

\subsection{Boolean Operators}
\setlx\ provides the following operators from
\href{https://en.wikipedia.org/wiki/Propositional_calculus}{propositional logic} to combine 
\href{https://en.wikipedia.org/wiki/Boolean_expression}{Boolean expressions}. 
\begin{enumerate}
\item ``\texttt{\&\&}'' denotes the logical \emph{and} (also known as \emph{conjunction}), so the expression
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{a \&\& b}
      \\[0.2cm]
      is \texttt{true} if and only if both \texttt{a} and \texttt{b} are \texttt{true}.
\item ``\texttt{||}'' denotes the logical \emph{or}, which is also known as \emph{disjunction}.
      Therefore,  the expression
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{a || b}
      \\[0.2cm]
      is \texttt{true} if either \texttt{a} or \texttt{b} or both are \texttt{true}.  
\item ``\texttt{!}'' denotes the logical \emph{not}, (also known as \emph{negation}).
      Therefore, the expression
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{!a}
      \\[0.2cm]
      is \texttt{true} if and only if \texttt{a} is \texttt{false}.  

      The first three Boolean operators work exactly as they work in \texttt{C} or \textsl{Java}.
\item ``\texttt{=>}'' denotes \href{https://en.wikipedia.org/wiki/Logical_consequence}{logical entailment}.
      Therefore, the expression
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{a => b}
      \\[0.2cm]
      is \texttt{true} if \texttt{a} is \texttt{false} or \texttt{b} is \texttt{true}. Hence the expression 
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{a => b}
      \\[0.2cm]
      has the same truth value as the expression
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{!a || b}.
\item ``\texttt{<==>}'' denotes the logical \emph{equivalence},
      so the expression
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{a <==> b}
      \\[0.2cm]
      is \texttt{true} if either  \texttt{a} and \texttt{b} are both \texttt{true} or \texttt{a} and
      \texttt{b} are both \texttt{false}. Therefore,  the expression 
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{a <==> b}
      \\[0.2cm]
      has the same value as the expression
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{(a \&\& b) || (!a \&\& !b)}.
      \\[0.2cm]
      As the equality operator ``\texttt{==}'' can also be used for logical values, the expression
      ``\texttt{a <==> b}'' is equivalent to the expression ``\texttt{a == b}''.
\item ``\texttt{<!=>}'' denotes the \href{https://en.wikipedia.org/wiki/Exclusive_or}{exclusive or} operator,  
      which is also known as logical \emph{antivalence},  hence the expression
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{a <!=> b}
      \\[0.2cm]
      is \texttt{true} if the truth values of \texttt{a} and \texttt{b} are different.  Therefore,  the expression 
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{a <!=> b}
      \\[0.2cm]
      is equivalent to the expression
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{!(a <==> b)}.
      \\[0.2cm]
      The expression ``\texttt{a <!=> b}'' yields the same result as the expression ``\texttt{a != b}''.
\end{enumerate}
While the operators ``\texttt{==}'' and ``\texttt{!=}'' can be used instead of the operators
``\texttt{<==>}'' and ``\texttt{<!=>}'', the precedence of these operators 
differ.  While the precedence of ``\texttt{<==>}'' and ``\texttt{<!=>}'' is lower than the
precedence of any other operator,  the precedence of ``\texttt{==}'' and ``\texttt{!=}'' is lower
than the precedence of the arithmetical operators like ``\texttt{+}'' and ``\texttt{*}'', but higher
than the precedence of the logical operators ``\texttt{\&\&}'' and ``\texttt{||}''.  Therefore, we
recommend the use of ``\texttt{<==>}'' and ``\texttt{<!=>}'' when comparing Boolean expressions.

\subsection{Quantifiers}
In addition to the propositional operators, \setlx\ supports both the
\href{https://en.wikipedia.org/wiki/Universal_quantification}{universal quantifier} 
``\texttt{forall}'' and the 
\href{https://en.wikipedia.org/wiki/Existential_quantification}{existential quantifier} ``\texttt{exists}''.
For example, to test whether the formula  
\\[0.2cm]
\hspace*{1.3cm}
$\forall x \in \{ 1, \cdots, 10 \}: x^2 \leq 2^x$
\\[0.2cm]
is \texttt{true}, we can evaluate the following expression:
\\[0.2cm]
\hspace*{1.3cm}
\texttt{forall (x in \{1..10\} | x ** 2 <= 2 ** x);}
\\[0.2cm]
This expression checks whether $x^2$ is less than or equal to $2^x$ for all $x$ between 1 and
10.  Syntactically, a \texttt{forall} expression is described by the following grammar
rule: 
\\[0.2cm]
\hspace*{1.3cm}
$\textsl{expr} \;\rightarrow\; \quoted{forall} \quoted{(} \textsl{var} \quoted{in}
 \textsl{expr} \quoted{|} \textsl{cond} \quoted{)}
$
\\[0.2cm]
Here, \textsl{var} denotes a variable and \textsl{expr} is an expression that evaluates
to a set $s$ (or a list  or a string), while \textsl{cond} is a Boolean expression.  The
\texttt{forall} expression evaluates to \texttt{true} if for all elements of $s$ the
condition \textsl{cond} evaluates to \texttt{true}.  There is a generalization of the grammar rule 
that allows to check several variables simultaneously, so we can write an expression like
the following:
\\[0.2cm]
\hspace*{1.3cm}
\texttt{forall (x in \{1..10\}, y in [20..30] | x < y)}.
\\[0.2cm]
If instead we want to know whether the formula
\\[0.2cm]
\hspace*{1.3cm}
$\exists x \in \{ 1, \cdots, 10 \}: 2^x < x^2$
\\[0.2cm]
is \texttt{true}, we have to write:
\\[0.2cm]
\hspace*{1.3cm}
\texttt{exists (x in \{1..10\} | 2 ** x < x ** 2);}
\\[0.2cm]
This expression checks whether there exists a natural number $x \in \{1, \cdots, 10\}$
such that $2^x< x^2$.
\vspace*{0.3cm}

\noindent
\textbf{Important}:  The quantifiers \texttt{forall} and \texttt{exists} expressions do \underline{not}
create their own local scope.  For example, the sequence of statements
\begin{verbatim}
    exists ([x, y] in {[a,b] : a in {1..10}, b in {1..10}} | 3*x - 4*y == 5);
    print("x = $x$, y = $y$");
\end{verbatim}
will print
\\[0.2cm]
\hspace*{1.3cm}
\texttt{x = 3, y = 1}
\\[0.2cm]
since for \texttt{x = 3} and \texttt{y = 1} the equation
\\[0.2cm]
\hspace*{1.3cm}
\texttt{3*x - 4*y == 5}
\\[0.2cm]
is \texttt{true}.
This example shows that the values of the variables \texttt{x} and \texttt{y} is available
outside of the existentially quantified expression.  The execution of
a \texttt{forall} or an \texttt{exists} expression stops as soon as the
truth value of the statement is known.
This feature is quite useful if the actual value of the variable in an \texttt{exists}
statement is needed.  It is also useful for a \texttt{forall} statement in case that the
\texttt{forall} statement fails.  For example, the expression
\\[0.2cm]
\hspace*{1.3cm}
\texttt{forall (n in [1..10] | n**2 <= 2**n);}
\\[0.2cm]
evaluates to \texttt{false} and, furthermore, it assigns the value $3$ to the variable \texttt{n},
since $3$ is the first integer in the list \texttt{[1..10]}
such that the expression $n^2 \leq 2^n$ is \texttt{false}.  In the case that an expression of the form
\\[0.2cm]
\hspace*{1.3cm}
\texttt{forall ($x$ in $s$ | $f(x)$)}
\\[0.2cm]
is \texttt{true},  the variable $x$ will be set to the undefined value \texttt{om}.  Similarly, if an
expression of the form
\\[0.2cm]
\hspace*{1.3cm}
\texttt{exists ($x$ in $s$ | $f(x)$)}
\\[0.2cm]
is \texttt{false}, the variable $x$ is set  to the undefined value \texttt{om}.

\section{Sets}
The most interesting data type provided by \setlx\ is the \emph{set} type.  
According to \href{https://en.wikipedia.org/wiki/Georg_Cantor}{Georg Cantor}, who invented set
theory, the definition of the notion of a set runs as follows:
\vspace*{0.4cm}

\begin{minipage}{0.8\linewidth}
\textsl{A \href{https://en.wikipedia.org/wiki/Set_(mathematics)}{\emph{set}} is 
a gathering together into a whole of definite, distinct objects of our perception or of our thought
--- which are called elements of the set \cite{cantor:1895}.}
\end{minipage}
\vspace*{0.4cm}

\noindent
This definition has two important implications:
\begin{enumerate}
\item Since the elements of a set are distinct, a set contains an object as most once.
      Hence, an object cannot occur multiple times in  a set.
\item A set is defined by its elements.  Two sets are identical if and only if they have the same elements.
\end{enumerate}
To create a set containing the numbers $1$, $2$, and $3$, we list these numbers inside curly braces:
\\[0.2cm]
\hspace*{1.3cm}
\texttt{S := \{1, 2, 3\};}
\\[0.2cm]
This creates a set containing the numbers $1$, $2$, and $3$ as elements.  In general, if we want to
combine the objects
\\[0.2cm]
\hspace*{1.3cm}
$o_1$, $o_2$, $o_3$, $\cdots$, $o_n$
\\[0.2cm]
into a set, we have to surround these objects by the curly braces ``\texttt{\{}'' and
``\texttt{\}}'' as follows:
\\[0.2cm]
\hspace*{1.3cm}
$\{ o_1,\; o_2,\; o_3,\; \cdots,\; o_n \}$
\\[0.2cm]
As two sets are equal if they contain the same elements, the order in which the elements are listed
does not matter.  For example, the comparison
\\[0.2cm]
\hspace*{1.3cm}
\texttt{\{1,2,3\} == \{2,3,1\}}
\\[0.2cm]
yields the result
\\[0.2cm]
\hspace*{1.3cm}
\texttt{true}.
\\[0.2cm]
This behaviour can lead to results that are sometimes surprising for the novice.  For example, the command
\\[0.2cm]
\hspace*{1.3cm}
\texttt{print(\{3,2,1\});}
\\[0.2cm]
yields the following output:
\\[0.2cm]
\hspace*{1.3cm}
\texttt{\{1, 2, 3\}}
\\[0.2cm]
The reason is, that \setlx\ does not remember the order of the insertion of different elements into
a set, \setlx\ just remembers the elements and sorts them internally to maximize the efficiency of
looking them up.

To check whether a set contains a given entity as an element, \setlx\ provides the binary infix
operator ``\texttt{in}''.  For example, the command
\\[0.2cm]
\hspace*{1.3cm}
\texttt{2 in \{1,2,3\};}
\\[0.2cm]
yields the result \texttt{true}, as $2$ is indeed an element of the set $\{1,2,3\}$, while 
\\[0.2cm]
\hspace*{1.3cm}
\texttt{4 in \{1,2,3\};}
\\[0.2cm]
 returns \texttt{false}.

The data type of a set would be quite inconvenient to use if we could only create sets by
explicitly listing all their elements.  Fortunately, there are some more powerful expressions to
define sets.  The operator that is most straightforward to use is the \emph{range operator} that can create a set
containing all the integers in a given range.  For example, to create the set containing
the integers from 1 up to 16, we can write 
\\[0.2cm]
\hspace*{1.3cm}
\texttt{\{1..16\};}
\\[0.2cm]
This expression returns the result
\\[0.2cm]
\hspace*{1.3cm}
\texttt{\{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16\}}.
\\[0.2cm]
In general, for integers $a$ and $b$
such that $a \leq b$,
the expression
\\[0.2cm]
\hspace*{1.3cm}
\texttt{\{$a$..$b$\}}
\\[0.2cm]
will generate the set of all integers starting from $a$ up to and including the number
$b$.  Mathematically, the semantics of this operator is  given by the formula
\\[0.2cm]
\hspace*{1.3cm}
\texttt{\{$a$..$b$\} = $\{ a + n \mid a \in \mathbb{Z} \wedge a + n \leq b\}$.}
\\[0.2cm]
Here $\mathbb{Z}$ denotes the set of all integers.
If $b$ is less than $a$, then the expression 
\\[0.2cm]
\hspace*{1.3cm}
\texttt{\{$a$..$b$\}}
\\[0.2cm]
denotes the empty set $\{\}$.

While successive elements of a set created by the expression ``\texttt{\{$a$..$b$\}}''
differ by $1$, there is a variant of the range operator that allows us to
specify the size of the difference between successive elements.   For example, the expression
\\[0.2cm]
\hspace*{1.3cm}
\texttt{\{1,3..10\};}
\\[0.2cm]
yields the set
\\[0.2cm]
\hspace*{1.3cm}
\texttt{\{1, 3, 5, 7, 9\}}.
\\[0.2cm]
In general, when a set definition of the form
\\[0.2cm]
\hspace*{1.3cm}
\texttt{\{$a$,$b$..$c$\}}
\\[0.2cm]
is evaluated, there are two cases.
\begin{enumerate}
\item $a < b$.  In this case, the \textsl{step size} $s$ is defined as
      \\[0.2cm]
      \hspace*{1.3cm}
      $s := b - a$.
      \\[0.2cm]
      Then, we have
      \\[0.2cm]
      \hspace*{1.3cm}
      $\texttt{\{$a$,$b$..$c$\}} := 
       \{ a + n \cdot s \mid n \in \mathbb{N}_0 \wedge a + n \cdot s \leq c  \}
      $.
      \\[0.2cm]
      Here, $\mathbb{N}_0$ denotes the set of all \href{https://en.wikipedia.org/wiki/Natural_number}{natural numbers} 
      where we take the convention that $0$ is a natural number.  The set of all positive integers will be
      denoted as $\mathbb{N}$. 
\item $a > b$.  In this case, the \textsl{step size} $s$ is defined as
      \\[0.2cm]
      \hspace*{1.3cm}
      $s := a - b$.
      \\[0.2cm]
      Then, we have
      \\[0.2cm]
      \hspace*{1.3cm}
      $\texttt{\{$a$,$b$..$c$\}} := 
       \{ a + n \cdot s \mid n \in \mathbb{N}_0 \wedge a + n \cdot s \geq c  \}
      $.
      \\[0.2cm]
      For example, we have
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{\{10, 8..1\} = \{10, 8, 6, 4, 2\}}.
\end{enumerate}

\subsection{Operators on Sets}
The following operators act on sets:
\begin{enumerate}
\item ``\texttt{+}'' is used to compute the \href{https://en.wikipedia.org/wiki/Union_(set_theory)}{union} of two sets.

      In mathematics, the union of two sets $S_1$ and $S_2$ is  written
      as $S_1 \cup S_2$.  It is defined as
      \\[0.2cm]
      \hspace*{1.3cm}
      $S_1 \cup S_2 := \{ x \mid x \in S_1 \vee x \in  S_2 \}$.
\item ``\texttt{*}'' computes the \href{https://en.wikipedia.org/wiki/Intersection_(set_theory)}{intersection} of two sets. 

      In mathematics, the intersection of two sets $S_1$ and $S_2$ is  written
      as $S_1 \cap S_2$.  It is defined as
      \\[0.2cm]
      \hspace*{1.3cm}
      $S_1 \cap S_2 := \{ x \mid x \in S_1 \wedge x \in  S_2 \}$.
\item ``\texttt{-}'' computes the \emph{difference} of two sets.  In set theory, the difference of two sets is
      also known as the
      \href{https://en.wikipedia.org/wiki/Complement_(set_theory)#Relative_complement}{relative complement} of
      these sets.  In mathematics, the difference of two sets $S_1$ and $S_2$ is often written
      as $S_1 \symbol{92} S_2$.  It is defined as
      \\[0.2cm]
      \hspace*{1.3cm}
      $S_1 \symbol{92} S_2 := \{ x \in S_1 \mid x \notin S_2 \}$.
\item ``\texttt{><}'' computes the \href{https://en.wikipedia.org/wiki/Cartesian_product}{Cartesian product} of two sets.

      In mathematics, the Cartesian product of two sets $S_1$ and $S_2$ is written
      as $S_1 \times S_2$.  It is defined as the set of all pairs $[x_1,x_2]$ such that $x_1$ is an
      element of $S_1$ and $x_2$ is an element of $S_2$:
      \\[0.2cm]
      \hspace*{1.3cm}
      $S_1 \times S_2 := \{ [x_1,x_2] \mid x_1 \in S_1 \wedge x_2 \in S_2 \}$.
\item ``\texttt{** 2}'' computes the \emph{Cartesian product} of a set with itself,
      i.e.~we have 
      \\[0.2cm]
      \hspace*{1.3cm}
      $S \;\mathtt{**}\; 2 := S \times S$.
\item ``\texttt{2 ** }'' computes the \href{https://en.wikipedia.org/wiki/Power_set}{power set} of a given set.
      For a given set $S$, the power set of $S$ is defined as the set of all
      \href{https://en.wikipedia.org/wiki/Subset}{subsets} of $S$. In mathematics, the power set of a given set
      $S$ is written as $2^S$ and the formal definition is
      \\[0.2cm]
      \hspace*{1.3cm}
      $2^S := \{ m \mid m \subseteq S \}$.
      \\[0.2cm]
      Here, the expression $m \subseteq S$ is \texttt{true} iff $m$ is a subset of $S$, i.e.~if all elements of
      $m$ are elements of $S$.  For example, the expression
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{2 ** \{1,2,3\}}
      \\[0.2cm]
      yields the result
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{\{\{\}, \{1\}, \{1, 2\}, \{1, 2, 3\}, \{1, 3\}, \{2\}, \{2, 3\}, \{3\}\}}.
\item ``\texttt{\symbol{37}}'' computes the \href{https://en.wikipedia.org/wiki/Symmetric_difference}{symmetric
      difference} of two sets. 

      In mathematics, the symmetric difference of two sets $S_1$ and $S_2$ is often written
      as $S_1 \triangle S_2$.  It is defined as
      \\[0.2cm]
      \hspace*{1.3cm}
      $S_1 \triangle S_2 := (S_1 \backslash S_2) \cup (S_2 \backslash S_1)$.
      \\[0.2cm]
      For example, the expression
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{\{1,2,3\} \% \{3,4,5\}}
      \\[0.2cm]
      yields the result
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{\{1, 2, 4, 5\}}.
\end{enumerate}
To give more examples, the commands
\\[0.2cm]
\hspace*{1.3cm}
\texttt{S1 := \{ 1, 2 \}; S2 := \{ 2, 3 \};}
\\
\hspace*{1.3cm}
\texttt{print("S1 + \ S2 = \symbol{36}S1 + \ S2\symbol{36}");}
\\
\hspace*{1.3cm}
\texttt{print("S1 - \ S2 = \symbol{36}S1 - \ S2\symbol{36}");}
\\
\hspace*{1.3cm}
\texttt{print("S1 * \ S2 = \symbol{36}S1 * \ S2\symbol{36}");}
\\
\hspace*{1.3cm}
\texttt{print("S1 ** \ 2  = \symbol{36}S1 ** 2\ \symbol{36}");}
\\
\hspace*{1.3cm}
\texttt{print("2 \ ** S2  = \symbol{36}2 \ ** S2\symbol{36}");}
\\
\hspace*{1.3cm}
\texttt{print("S1 >< S2 = \symbol{36}S1 >< S2\symbol{36}");}
\\
\hspace*{1.3cm}
\texttt{print("S1 \symbol{37} \ S2 = \symbol{36}S1 \symbol{37} \ S2\symbol{36}");}
\\[0.2cm]
will produce the follwing results:
\begin{verbatim}
        S1 +  S2 = {1, 2, 3}
        S1 -  S2 = {1}
        S1 *  S2 = {2}
        S1 **  2 = {[1, 1], [1, 2], [2, 1], [2, 2]}
        2  ** S2 = {{}, {2}, {2, 3}, {3}}
        S1 >< S2 = {[1, 2], [1, 3], [2, 2], [2, 3]}
        S1 %  S2 = {1, 3}
\end{verbatim}
For sets, the exponentiation operator ``\texttt{**}'' is only defined if either the base
of the exponentiation is a set and the exponent is the number $2$ or the base is the
number $2$ and the exponent is a set.  Therefore, if $S$ is a set, expressions like
\\[0.2cm]
\hspace*{1.3cm}
\texttt{3 ** $S$} \quad and \quad \texttt{$S$ ** 3}
\\[0.2cm]
are undefined. 
Also note the use of \href{https://en.wikipedia.org/wiki/String_interpolation}{string interpolation} in the
\texttt{print} statements given above:  Inside a string, any expression enclosed in
\symbol{36}-symbols is evaluated and the result of this evaluation is
inserted into the string.
String interpolation will be discussed in more detail later when we explain how strings are
supported in \setlx.

For all of the binary operators discussed above there is a variant of
the assignment operator that incorporates the binary operator.  For example, the command
\\[0.2cm]
\hspace*{1.3cm}
\texttt{S += \{x\};}
\\[0.2cm]
adds the element \texttt{x} to the set \texttt{S}, while the command
\\[0.2cm]
\hspace*{1.3cm}
\texttt{S -= \{x\};}
\\[0.2cm]
removes the element \texttt{x} from the set \texttt{S}.  Of course,
these modified assignment operators can also be used when the arguments are numbers, i.e.~the statement
\\[0.2cm]
\hspace*{1.3cm}
\texttt{x += 1;}
\\[0.2cm]
increments the value of the variable \texttt{x} by $1$.
\vspace*{0.2cm}

In addition to the basic operators discussed above,
\setlx\ provides a number of more elaborate operators for sets.  One of these operators is
the cardinality operator ``\texttt{\#}'', which computes the number of elements of a 
given set.  The cardinality operator is used as a unary prefix operator, for example we can write:
\\[0.2cm]
\hspace*{1.3cm}
\texttt{\# \{5,7,13\}};
\\[0.2cm]
Of course, in this example the result will be $3$.
We can sum the elements of a set using the prefix operator
``\texttt{+/}''.  For example, in order to
compute the sum 
\\[0.2cm]
\hspace*{1.3cm}
$\ds\sum\limits_{i=1}^{6^2} i = 1 + 2 + \cdots + 35 + 36$,
\\[0.2cm]
we can create the set \texttt{\{1..6**2\}} containing all the numbers
that have to be summed and then use the command
\\[0.2cm]
\hspace*{1.3cm}
\texttt{+/ \{1..6**2\}; }
\\[0.2cm]
to calculate the actual sum.
For arguments that are numbers, ``\texttt{**}'' is the \href{https://en.wikipedia.org/wiki/Exponentiation}{exponentiation} operator.
Therefore, the expression given above 
first computes the set of all numbers from 1 up to the number 36 and then returns the sum
of all these numbers.  There is also a binary version of the operator ``\texttt{+/}'' that
is used as an infix operator.  For a number $x$ and a set $S$, the expression
\\[0.2cm]
\hspace*{1.3cm}
\texttt{$x$ +/ $S$}
\\[0.2cm]
will insert $x$ into the set $S$ if the set $S$ is empty.  After that, it returns the sum of all elements in the
resulting set.  This is useful as the expression ``\texttt{+/ \{\}}'' is undefined.  It is undefined because
\setlx\ is not able to decide whether the empty set is to be interpreted as a set of numbers or as a set of sets.
So if we want to compute the sum of all numbers in $S$ but we are not sure whether $S$ might
be empty, we can use the expression
\\[0.2cm]
\hspace*{1.3cm}
\texttt{0 +/ S}
\\[0.2cm]
since inserting $0$ into the empty set guarantees that the result is 0 in case  the set
\texttt{S} is empty.  If $S$ is a set whose elements are sets themselves, the expression
\\[0.2cm]
\hspace*{1.3cm}
\texttt{+/} $S$
\\[0.2cm]
computes the union of the sets that are elements of the set $S$.  For example, the expression
\\[0.2cm]
\hspace*{1.3cm}
\texttt{+/ \{ \{1,2,3\}, \{3,4,5\}, \{5,6,7\} \}}
\\[0.2cm]
yields the result
\\[0.2cm]
\hspace*{1.3cm}
\texttt{\{1, 2, 3, 4, 5, 6, 7\}.}
\\[0.2cm]
There is a similar operator for multiplying the elements of a set: It is the operator
``\texttt{*/}''.
For example, in order to compute the \href{https://en.wikipedia.org/wiki/Factorial}{factorial\footnote{
  The factorial operator ``\texttt{!}'' is a builtin postfix operator.  Computing
  the factorial of a number using this operator is more efficient than first building a set
  and then using the operator ``\texttt{*/}''.
}}
$n! = 1 \cdot 2 \cdot 3 \cdot {\dots} \cdot (n-1) \cdot n$ we can use the expression
\\[0.2cm]
\hspace*{1.3cm}
\texttt{*/ \{1..n\}}.
\\[0.2cm]
Again, there is also a binary version of this operator.  Since the number $1$ is the
neutral element for  multiplication, the first argument to this operator will most often
be one.   Therefore, the expression
\\[0.2cm]
\hspace*{1.3cm}
\texttt{1 */ S}
\\[0.2cm]
 multiplies all the numbers from a the set $S$ and this expression will return $1$ if the
 set $S$ happens to be empty.  

If $S$ is a set whose elements are sets themselves, the expression
\\[0.2cm]
\hspace*{1.3cm}
\texttt{*/} $S$
\\[0.2cm]
computes the intersection of the sets that are elements of the set $S$.  For example, the expression
\\[0.2cm]
\hspace*{1.3cm}
\texttt{*/ \{ \{1,2,3\}, \{2,3,4\} \}}
\\[0.2cm]
yields the result
\\[0.2cm]
\hspace*{1.3cm}
\texttt{\{2, 3\}.}

\subsection{Set Comprehensions}
We can use \emph{set comprehension} to build sets.  For example, the command
\\[0.2cm]
\hspace*{1.3cm}
\texttt{\{ a * b: a in \{ 1..3 \}, b in \{ 1..3 \} \};}
\\[0.2cm]
computes the set of all products $a * b$ where both $a$ and $b$ run from $1$ to $3$.
The command will therefore compute the set
\\[0.2cm]
\hspace*{1.3cm}
\texttt{\{1, 2, 3, 4, 6, 9\}}.
\\[0.2cm]
In general, a \emph{set comprehension expression} has the form
\\[0.2cm]
\hspace*{1.3cm}
\texttt{\{ $\textsl{expr}$ :$\;x_1$ in $S_1$, $\cdots$, $x_n$ in $S_n$ | $\textsl{cond}$ \}}.
\\[0.2cm]
Here, \textsl{expr} is some expression containing the variables $x_1$, $\cdots$, $x_n$, while
$S_1$, $\cdots$, $S_n$ are either sets or lists (to be discussed later) or strings, and $\textsl{cond}$ is an
expression returning a Boolean value.  
The  set comprehension expression given above evaluates $\textsl{expr}$ for all possible combinations of 
values $x_1 \in S_1$, $\cdots$, $x_n \in S_n$ such that $\textsl{cond}$ is \texttt{true} and it will add the
corresponding value of $\textsl{expr}$ into the resulting set.
The expression $\textsl{cond}$ is optional.  If it is missing, it is implicitly taken to be
always \texttt{true}.

We are now ready to demonstrate some of the power that comes with sets.  
The following two statements compute the set of all \href{https://en.wikipedia.org/wiki/Prime_number}{prime numbers} smaller than $100$:
\\[0.2cm]
\hspace*{1.3cm}
\texttt{S := \{2..100\};}
\\
\hspace*{1.3cm}
\texttt{S - \{ p * q : p in S, q in S \};}
\\[0.2cm]
Since a prime number is any number bigger than 1 that is not a proper product, this expression computes the set
of prime numbers smaller than $100$.  
Obviously, this is not an efficient way to calculate primes, but efficiency is not the
point of this example.  It rather shows that \setlx\ is well suited to execute a
mathematical definition as it is.

Let us look at another example of set comprehension:  The expression
\\[0.2cm]
\hspace*{1.3cm}
\texttt{\{ p:$\;$p in \{2..100\} | \{ t:$\;$t in \{2..p-1\} | p \% t == 0 \} == \{\} \}}
\\[0.2cm]
yields the set of all prime numbers less than 100.  The subexpression
\\[0.2cm]
\hspace*{1.3cm}
\texttt{\{ t:$\;$t in \{2..p-1\} | p \% t == 0 \}}
\\[0.2cm]
computes the set of all those natural numbers \texttt{t} less than \texttt{p} that divide
\texttt{p} evenly.  If this set is empty, then, by the definition of a prime number, \texttt{p} is prime.

The syntax for building set comprehensions is a little bit more
general than discussed above.  Provided $S_1$, $\cdots$, $S_n$ are sets of \emph{lists},
where all of the lists in the set $S_i$ have the same length $m_i$, a set comprehension expression
can take the form
\\[0.2cm]
\hspace*{1.3cm}
\texttt{\{ $\textsl{expr}$ :$\;[x_1,x_2,\cdots,x_{m_1}]$ in $S_1$, $\cdots$, $[z_1,z_2,\cdots, z_{m_n}]$ in $S_n$ | $\textsl{cond}$ \}}.
\\[0.2cm]
This kind of set comprehension expressions will be discussed further when discussing lists.

\subsection{Miscellaneous Set Functions}
In addition to the operators provided for sets, \setlx\ has a number of functions targeted at sets.
The first of these functions is \texttt{arb}.  For a set $S$,  an expression of the form
\\[0.2cm]
\hspace*{1.3cm}
\texttt{arb($S$)}
\\[0.2cm]
yields some element of the set $S$.  The element returned is not specified, so the expression
\\[0.2cm]
\hspace*{1.3cm}
\texttt{arb(\{1,2,3\});}
\\[0.2cm]
might yield either $1$, $2$, or $3$.  The function \texttt{from} has a similar effect, so
\\[0.2cm]
\hspace*{1.3cm}
\texttt{from($S$)}
\\[0.2cm]
also returns some element of the set $S$.  In addition, the function $\mathtt{from}$ removes this element from
the set $S$.  Therefore, if the set \texttt{S} is defined via
\\[0.2cm]
\hspace*{1.3cm}
\texttt{S := \{1,2,3\};}
\\[0.2cm]
and we execute the statement 
\\[0.2cm]
\hspace*{1.3cm}
\texttt{x := from(S);}
\\[0.2cm]
then some\footnote{We do not know which of the elements of \texttt{S} is assigned to \texttt{x}.} of the
element of \texttt{S} is assigned to \texttt{x} and this element is removed from  
the set \texttt{S}.  For example, after this assignment, we might possibly have
\\[0.2cm]
\hspace*{1.3cm}
\texttt{x == 3} \quad and \quad \texttt{S == \{1,2\}}.
\\[0.2cm]
Of course, we could just as well have
\\[0.2cm]
\hspace*{1.3cm}
\texttt{x == 1} \quad and \quad \texttt{S == \{2,3\}}
\\[0.2cm]
as a result of the assignment ``\texttt{x := from(S);}''.

For a set $S$,  the expression 
\\[0.2cm]
\hspace*{1.3cm}
\texttt{first($S$)}
\\[0.2cm]
returns the \emph{first} element of the set $S$, while
\\[0.2cm]
\hspace*{1.3cm}
\texttt{last($S$)} 
\\[0.2cm]
yields the \emph{last} element.  Internally, sets are represented as ordered binary trees.  As long
as the sets contain only numbers, the ordering of these elements is the usual ordering on
numbers. Therefore, in this case the \emph{first element} is just the smallest number and the 
\emph{last element} is the biggest number.  If a set $S$ contains sets (or lists), these sets (or
lists) are themselves compared lexicographically.  
Things get a little bit more complicated if a set $S$ is heterogeneous and contains both number and sets.
Programs should not rely on the ordering implemented in these cases.

For a given set $S$, the expression
\\[0.2cm]
\hspace*{1.3cm}
\texttt{rnd($S$)}
\\[0.2cm]
yields a random element of the set $S$.  
In contrast to the expression
``\texttt{arb($S$)}'',  this expression will in general return different results on
different invocations.  The function \texttt{rnd} also works for lists, so for a list $L$
the expression $\texttt{rnd}(L)$ returns a random element of $L$.
The function $\mathtt{rnd}()$ is also supported for integer numbers, for example the expression
\\[0.2cm]
\hspace*{1.3cm}
\texttt{rnd(5)}
\\[0.2cm]
computes a random non-negative integer less than or equal to $5$. Essentially, the expression
\texttt{rnd(5)} is equivalent to the expression
\texttt{rnd(\{0..5\})}.  While we are at it: The function \texttt{random} computes pseudo-random
real numbers in the interval $[0,1]$.  This function does not take an argument. Therefore, the expression
\\[0.2cm]
\hspace*{1.3cm}
\texttt{random()}
\\[0.2cm]
might output a value like \texttt{0.5171688974345957}. 


\section{Lists}
Besides sets, \setlx\ also supports lists.  Syntactically, the main difference between sets and
lists is that the
curly braces ``\texttt{\{}'' and ``\texttt{\}}'' are replaced by the square brackets
``\texttt{[}'' and ``\texttt{]}''.  Semantically, while a set is an unordered collection of elements
that can contain any element at most once, a list is an ordered collection of elements that 
can contain an element multiple times.  For example
\\[0.2cm]
\hspace*{1.3cm}
\texttt{[3,4,7,2,5,3]}
\\[0.2cm]
is a typical list.  Note that the element $3$ occurs twice in this list.  The easiest way to
construct a list is by listing the elements explicitly. For 
example, the assignment
\\[0.2cm]
\hspace*{1.3cm}
\texttt{L := [1,4,7,2,4,7]}
\\[0.2cm]
defines the list \texttt{[1,4,7,2,4,7]} and assigns it to the variable \texttt{L}.
Another way to construct lists is via the range operator ``\texttt{..}'':
For example, the expression
\\[0.2cm]
\hspace*{1.3cm}
\texttt{[1..10]}
\\[0.2cm]
returns the list
\\[0.2cm]
\hspace*{1.3cm}
\texttt{[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]}.
\\[0.2cm]
The prefix operators ``\texttt{+/}'' and ``\texttt{*/}'' work for lists in the same way that they
work for sets: ``\texttt{+/ L}'' computes the sum of all elements of the list \texttt{L}, while
``\texttt{*/ L}'' computes the product of the elements of \texttt{L}.  For example, the expression
\\[0.2cm]
\hspace*{1.3cm}
\texttt{+/ [1..100]}
\\[0.2cm]
yields the result $5050$.

\emph{List comprehension} works similar to set comprehension: Given sets or lists $S_1$, $\cdots$, $S_n$, the expression
\\[0.2cm]
\hspace*{1.3cm}
\texttt{[ $\textsl{expr}$ :$\;x_1$ in $S_1$, $\cdots$, $x_n$ in $S_n$ | $\textsl{cond}$ ]}
\\[0.2cm]
 picks up all lists 
\\[0.2cm]
\hspace*{1.3cm}
$[x_1, \cdots, x_n ] \in S_1 \times \cdots \times S_n$
\\[0.2cm]
such that the $i$th element $x_i$ is a member of $S_i$ and that
 $\textsl{cond}$ is \texttt{true} and then evaluates $\textsl{expr}$ for the corresponding values of the
variables $x_1$, $\cdots$, $x_n$.  Finally, the value of $\textsl{expr}$ is
inserted into the resulting list.  For example, the following expression  computes all primes up
to 100: 
\\[0.2cm]
\hspace*{1.3cm}
\texttt{[ p : p in [2..100] | \{ x : x in \{1..p\} | p \% x == 0 \} == \{1, p\} ]}.
\\[0.2cm]
Here, the idea is that a number $p$ is prime if the set of its divisors, which is the set
of all numbers $x$ such that $p \;\texttt{\%}\; x = 0$, only contains the number $1$ and
the number $p$. 

The syntax for building lists via comprehensions is a little bit more
general than discussed above.  Provided $S_1$, $\cdots$, $S_n$ are sets or lists
such that all of the elements of $S_i$ are lists that have the same length $m_i$, a list 
can be defined as
\\[0.2cm]
\hspace*{1.3cm}
\texttt{[ $\textsl{expr}$ :$\;[x_1,x_2,\cdots,x_{m_1}]$ in $S_1$, $\cdots$, $[z_1,z_2,\cdots, z_{m_n}]$ in $S_n$ | $\textsl{cond}$ ]}.
\\[0.2cm]
For example, assume that \texttt{R1} and \texttt{R2} are sets containing \emph{pairs} of elements, where a
\emph{pair} is just a list of length two.  In this case, \texttt{R1} and \texttt{R2} could be viewed as 
\href{https://en.wikipedia.org/wiki/Binary_relation}{binary relations}.  Then, the 
\href{https://en.wikipedia.org/wiki/Composition_of_relations}{relational composition} of \texttt{R1} and
\texttt{R2} is defined as
\\[0.2cm]
\hspace*{1.3cm}
$\mathtt{R1} \circ \mathtt{R2} := \{ [x,z] \mid \exists y: [x,y] \in \mathtt{r1} \wedge [y,z] \in\mathtt{r2} \}$. 
\\[0.2cm]
In \setlx, this composition can be computed as 
\\[0.2cm]
\hspace*{1.3cm}
\texttt{\{ [x,z]:$\;$[x,y] in R1, [y,z] in R2 \}}.

\subsection{Operators on Lists}
Currently, there are four operators for lists.  These are discussed below.
\begin{enumerate}
\item The operator ``\texttt{+}'' concatenates its arguments.  For example
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{[1 .. 3] + [5 .. 10];}
      \\[0.2cm]
      yields 
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{[1, 2, 3, 5, 6, 7, 8, 9, 10]}.
\item The operator ``\texttt{*}'' takes a list as its first argument,  while the second argument
      needs to be a natural number.  An expression of the form 
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{l * n}
      \\[0.2cm]
      concatenates \texttt{n} copies of the list \texttt{l}.  Therefore, the expression
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{[1, 2, 3] * 3}
      \\[0.2cm]
      yields the result
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{[1, 2, 3, 1, 2, 3, 1, 2, 3]}.
\item The cardinality operator ``\texttt{\#}'' is a prefix operator that works for lists the same
      way it works for sets, i.e.~it returns the number of elements of the list given as argument.  For example,
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{\# [ 7, 4, 5 ];}
      \\[0.2cm]
      yields the result $3$.
\item The infix operator ``\texttt{><}'' takes two lists $L_1$ and $L_2$.  The length of $L_1$ has
      to be the same as the length of $L_2$.  The operator \emph{zips} the lists given as arguments
      to produce a list of pairs, where the first component of each  pair is from the list $L_1$,
      while the second component is the corresponding element from the list $L_2$.  For example, the
      expression      
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{[1, 2, 3] >< ["a", "b", "c"]};
      \\[0.2cm]
      returns the list
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{[[1, "a"], [2, "b"], [3, "c"]]}.
      \\[0.2cm]
      Formally, the behaviour of the operator ``\texttt{><}'' on lists $L_1$ and $L_2$ is specified as follows:
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{$L_1$ >< $L_2$ == [ [$L_1$[$i$], $L_2$[$i$]]:$\;i$ in [1$\;$..$\;$\#$L_1$] ]}.
      \\[0.2cm]
      Here, \texttt{$L$[$i$]} denotes the $i$-th element of the list $L$ and the lists $L_1$ and
      $L_2$ must have the same length.
\end{enumerate}

\subsection{Extracting Elements from a List}
As the elements of a list are ordered, it is possible to extract an element from a list with respect
to its position.  In general, for a list $L$ and a positive natural number $n$, the expression
\\[0.2cm]
\hspace*{1.3cm}
\texttt{$L$[$n$]}
\\[0.2cm]
selects the $n$-th element of $L$.  Of course, counting starts with $1$, so $L[1]$ is the first element
of the list $L$.  For example, after the assignment
\\[0.2cm]
\hspace*{1.3cm}
\texttt{L := [99, 88, 44];}
\\[0.2cm]
the expression 
\\[0.2cm]
\hspace*{1.3cm}
\texttt{L[2]}
\\[0.2cm]
yields the result $88$.  The right hand side of an extraction expression can also be a \emph{slicing operator}:
The expression
\\[0.2cm]
\hspace*{1.3cm}
\texttt{$L$[$a$..$b$]}
\\[0.2cm]
extracts the sublist of $L$ that starts at index $a$ and ends at index $b$.  For example,
after defining $L$ via the assignment
\\[0.2cm]
\hspace*{1.3cm}
\texttt{L := ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j" ];}
\\[0.2cm]
the expression
\\[0.2cm]
\hspace*{1.3cm}
\texttt{L[5..8]}
\\[0.2cm]
yields the sublist \texttt{["f", "g", "h"]}.  The  expression 
\\[0.2cm]
\hspace*{1.3cm}
\texttt{$L$[$a$..$b$]}
\\[0.2cm]
returns the empty list if $a > b$ and both $a$ and $b$ are positive.  

There are two more variants of the slicing operator.   The expression
\\[0.2cm]
\hspace*{1.3cm}
\texttt{$L$[$a$..]}
\\[0.2cm]
returns the sublist of $L$ that starts with the element at index $a$, and the expression
\\[0.2cm]
\hspace*{1.3cm}
\texttt{$L$[..$b$]}
\\[0.2cm]
computes the sublist of $L$ that starts at the first element and includes all the elements up to the
element at index $b$.

The index operator also works with negative indices.  For a nonempty list $l$, the expression
\\[0.2cm]
\hspace*{1.3cm}
\texttt{$L$[-1]}
\\[0.2cm]
selects the last element of $L$, while
\\[0.2cm]
\hspace*{1.3cm}
\texttt{$L$[-2]}
\\[0.2cm]
would select the second to last element, provided the list has at least two elements.  In general, for a list $L$ of length $n$ and an index 
$i\in \{1,\cdots,n\}$, the expression
\\[0.2cm]
\hspace*{1.3cm}
\texttt{$L$[-$i$]}
\\[0.2cm]
selects the element with index $n + 1 - i$, i.e.~for $i \in \{1,\cdots,n\}$ the expressions
\\[0.2cm]
\hspace*{1.3cm}
\texttt{$L$[-$i$]} \quad and \quad \texttt{$L$[$n+1-i$]}
\\[0.2cm]
are equivalent.  Negative indices also work with the slicing operator.  For example, for a list $L$
containing at least two elements, the expression
\\[0.2cm]
\hspace*{1.3cm}
\texttt{$L$[2..-2]}
\\[0.2cm]
returns the list that results from $L$ by chopping off both the first and the last element of $L$.
The variants
\\[0.2cm]
\hspace*{1.3cm}
\texttt{L[$a$..]} \quad and \quad \texttt{L[..$b$]}
\\[0.2cm]
also work with negative values of $a$ and $b$.  For example, the expression
\\[0.2cm]
\hspace*{1.3cm}
\texttt{$L$[..-2]}
\\[0.2cm]
returns a list containing all elements of $L$ but the last.

After a list is created, we can add new elements to the list by assigning to the list as the
following example demonstrates.  After defining \texttt{L} as
\\[0.2cm]
\hspace*{1.3cm}
\texttt{L := ["a", "b", "c"];}
\\[0.2cm]
we can use the assignment
\\[0.2cm]
\hspace*{1.3cm}
\texttt{L[5] := "e";}
\\[0.2cm]
to assign a fifth element to \texttt{L}.  Here, you might wonder how it is possible to add a
fifth element, as the list \texttt{L} does not have a fourth element.  However, after the assignment
shown above, we have
\\[0.2cm]
\hspace*{1.3cm}
\texttt{L == ["a", "b", "c", om, "e"]}.
\\[0.2cm]
Hence, in this case the fourth element is simply the undefined value \texttt{om}.

When indexing a list, the number $0$ is not allowed as an index.  Therefore, the expression
\\[0.2cm]
\hspace*{1.3cm}
\texttt{$L$[0]}
\\[0.2cm]
will yield the following error message:
\begin{verbatim}
    Error in "l[0]":
    Index '0' is invalid.
\end{verbatim}
However, the index $0$ is allowed as the second index in a range operator.  For example, the expression
\texttt{L[1..0]}
yields the empty list.


Lists of variables can be used on the left hand side of an assignment.  This feature enables the
\emph{simultaneous assignment} of several variables.  The statement
\\[0.2cm]
\hspace*{1.3cm}
\texttt{[x,y] := [1,2];}
\\[0.2cm]
sets the variable $x$ to 1 and $y$ to 2.  A more interesting example is the following assignment:
\\[0.2cm]
\hspace*{1.3cm}
\texttt{[y,x] := [x,y];}
\\[0.2cm]
This assignment swaps the values of the variables $x$ and $y$.

\section{Pairs, Relations,  and Functions}
In \textsc{Setl}, a pair of the form $\langle x, y \rangle$ is represented as the list $[x,y]$.
A set of pairs can be regarded as a \href{https://en.wikipedia.org/wiki/Binary_relation}{binary relation} and
the notion of a relation is a generalization of the notion of a
\href{https://en.wikipedia.org/wiki/Function_(mathematics)}{function}.   If $R$ is a binary relation, we 
define the \emph{domain} and \emph{range} of $R$ as the set containing the first and second component
of the pairs, that is we have
\\[0.2cm]
\hspace*{1.3cm}
\texttt{domain(R) := \{ x :$\;$[x,y] in R \}} \quad and \quad
\texttt{range(R)  := \{ y :$\;$[x,y] in R \}}.
\\[0.2cm]
Furthermore, if $R$ is a binary relation
such that 
\\[0.2cm]
\hspace*{1.3cm}
$[x,y_1] \in R \wedge [x,y_2] \in R \rightarrow y_1 = y_2$ 
\\[0.2cm]
holds for all $x$, $y_1$, and $y_2$, then $R$ is called a
\href{https://en.wikipedia.org/wiki/Map_(mathematics)}{map} and represents a 
\href{https://en.wikipedia.org/wiki/Function_(mathematics)}{function}.
Therefore, a map is a set of \texttt{[\textsl{key}, \textsl{value}]} pairs such that the
keys are \emph{unique}, i.e.~every key is associated with exactly one value.
If a binary relation $R$ is a map, \setlx\ permits us to use the relation $R$ as a function:  If $R$ is a map
and $x \in \textsl{domain}(R)$, then $R[x]$ denotes the unique element $y$ such that 
$\pair(x,y) \in R$:
\\[0.2cm]
\hspace*{1.3cm}
$R[x] := \left\{
\begin{array}{ll}
  y & \mbox{if the set $\{ y \mid [x,y] \in R\}$ contains exactly one element $y$;} \\[0.2cm]
  \Omega & \mbox{otherwise}.
\end{array} \right.
$
\\[0.2cm]
The program shown below in Figure
\ref{fig:map.stlx} provides a trivial example demonstrating how maps can be used
as functions in  \setlx.  
 

\begin{figure}[!ht]
  \centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    R := { [n, n*n] : n in {1..5} };
    print( "R[3]      = $R[3]$"      );
    print( "domain(R) = $domain(R)$" );
    print( "range(R)  = $range(R)$"  );
    R[2] := 17;
    print( "R         = $R$" );
\end{Verbatim} 
\vspace*{-0.3cm}
\caption{Binary relations as functions.}  \label{fig:map.stlx}
\end{figure} %$

\noindent
The program computes the map \texttt{R} that represents the function 
 $x \mapsto x \cdot x$ on the set
\\[0.2cm]
\hspace*{1.3cm}
 $\{n\in \mathbb{N} \mid 1 \leq n \wedge n \leq 5 \}$.  
\\[0.2cm] 
In line 2, the relation \texttt{R} is evaluated at $x=3$.  This is done using square brackets.
Next, $\textsl{domain}(\mathtt{R})$ and $\textsl{range}(\texttt{R})$ are computed.  Finally, the
assignment in line 5 changes the relation for the argument 2 to yield the value 17 instead of 4.
Hence, we get the following result:
\begin{verbatim}
        R[3]      = 9
        domain(R) = {1, 2, 3, 4, 5}
        range(R)  = {1, 4, 9, 16, 25}
        R         = {[1, 1], [2, 17], [3, 9], [4, 16], [5, 25]}
\end{verbatim}
It is a natural question to ask 
what happens if $R$ is a binary relation and we try to evaluate the expression 
$R(x)$ but the set \texttt{\{ y : $\hspace*{-0.2cm}$[x, y] in R \}}
is either empty or contains
more than one element.
The program shown in Figure \ref{fig:buggy-map.stlx} on page
\pageref{fig:buggy-map.stlx} answers this question.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    R := { [1, 1], [1, 4], [3, 3] };
    print( "R[1] = ", R[1] );
    print( "R[2] = ", R[2] );
    print( "{ R[1], R[2] } = ", { R[1], R[2] } );
    print( "R{1} = ", R{1} );
    print( "R{2} = ", R{2} );
\end{Verbatim}
\vspace*{-0.3cm}
\caption{A binary relation that is not a map.}
\label{fig:buggy-map.stlx}
\end{figure}


If the set \texttt{\{ y :[x, y] in R \}} is either empty or has more than one
element, then the expression \texttt{R[x]} is undefined.  In mathematics, an undefined value is
sometimes denoted as $\Omega$.  In \textsc{SetlX}, the undefined value is printed as ``\texttt{om}''.
If we try to add the undefined value to a set $M$, then $M$ is not changed.
Therefore, line 4 of the program shown in Figure \ref{fig:buggy-map.stlx}
prints the empty set, as both \texttt{R[1]} and \texttt{R[2]} are undefined.

We can use the notation  \texttt{R\{x\}} instead of \texttt{R[x]} to avoid undefined values.
For a binary relation $R$ and an object $x$, the expression $R\{x\}$ is defined as the set of those values $y$
such that the pair $\pair(x,y)$ is an element of $R$: 
\\[0.2cm]
\hspace*{1.3cm} 
\texttt{R\{x\} := \{ y :$\;$[x, y] in R \}}.
\\[0.2cm]
Hence, the  program shown in Figure \ref{fig:buggy-map.stlx} yields the following results:
\begin{verbatim}
    R[1] = om
    R[2] = om
    { R[1], R[2] } = {}
    R{1} = {1, 4}
    R{2} = {}
\end{verbatim}
Binary relations can also be used to represent functions accepting more than one argument.  For example, the
statements
\begin{verbatim}
    R := {};
    R[1,2] := 3;
    R[2,1] := 4;
\end{verbatim}
define a function that maps the pair $[1,2]$ to the value $3$, while the pair $[2,1]$ is mapped to
the value $4$.  If we print \texttt{R} after these statements have been executed, then the set
\\[0.2cm]
\hspace*{1.3cm}
\texttt{\{[[1, 2], 3], [[2, 1], 4]\}}
\\[0.2cm]
is stored in the variable \texttt{R}.
\vspace*{0.2cm}

\noindent
\textbf{Remark}:
This section has shown that binary relations can be used to represent the data type of a
\emph{dictionary}.  Other programming languages, for example \textsl{Perl} \cite{Wall92},
provide \href{https://en.wikipedia.org/wiki/Associative_array}{associative arrays} to represent dictionaries.
In most of the scripting languages 
providing associative arrays, these associative arrays are implemented as 
\href{http://en.wikipedia.org/wiki/Hash_table}{\emph{hash tables}}.  In the programming language
\textsc{Setl}, sets and relations were also represented via hash tables.
In contrast, the sets (and therefore the dictionaries) in \textsc{SetlX} are implemented as 
\href{http://en.wikipedia.org/wiki/Red-black_tree}{\emph{red-black trees}}.
Although implementing sets as red-black trees is slightly slower than a hash table based
implementation, the advantage of using red-black trees is that they support a number of operations
that are not available when using hash-tables.  The efficient implementation of the functions \texttt{first}
and \texttt{last} would be impossible if sets had been represented as hash tables.


\section{Procedures}
Although functions can be represented as binary relations, this is not the preferred way
to represent functions.  After all, using a relation to represent a function
has a big memory footprint and also requires to compute all possible function
values regardless of their later use.  Therefore, the preferred way to code a function is
to use a \emph{procedure}.  For example, Figure \ref{fig:primes.stlx} defines a procedure
to compute all 
\href{https://en.wikipedia.org/wiki/Prime_number}{prime numbers} up to a given natural number $n$.  The idea is
to take the set $s$ of all numbers in 
the range from $2$ upto $n$ and then to subtract the set of all non-trivial
products from this set.  This will leave us with the set of all prime numbers less or
equal to $n$ as a natural number is prime if and only if it is not a non-trivial product.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    primes := procedure(n) { 
        s := { 2..n }; 
        return s - { p*q : [p, q] in s >< s }; 
    };
\end{Verbatim}
\vspace*{-0.3cm}
\caption{A procedure to compute the prime numbers.}
\label{fig:primes.stlx}
\end{figure}

In Figure \ref{fig:primes.stlx}, the block starting with ``\texttt{procedure(n) \{}'' and
ending with the closing brace ``\texttt{\}}'' defines a function.  This function is then
assigned to the variable \texttt{primes}.  Therefore, a function is just another kind of a
value.  Conceptually, the type of functions is not different from the type of sets or the type of
strings:  A function can be assigned to a variable, it can be used as an argument to
another function and it can also be returned from another function.  To summarize,
functions are \href{http://en.wikipedia.org/wiki/First-class_function}{\emph{first class citizens}} 
in \setlx.  The ramifications of
this fact will be explained in Chapter \ref{chapter:closures} on functional programming
and \emph{closures}.
\vspace*{0.2cm}

\noindent
\textbf{Remark}:
A function defined using the keyword \texttt{procedure} is \textbf{not} able to read or write
variables that are defined outside of the function definition.  If you need access to variables
defined outside of the function, you have to define a \emph{closure} instead.  This is done by
substituting the keyword \texttt{procedure} with the keyword \texttt{closure}.  Closures are
discussed in more detail in Chapter \ref{chapter:closures} later.


\section{Strings}
Any sequence of characters enclosed in either double quotes or single quotes is considered a 
\href{https://en.wikipedia.org/wiki/String_(computer_science)}{string}.
Strings can be concatenated using the infix operator ``\texttt{+}'', so
\\[0.2cm]
\hspace*{1.3cm}
\texttt{\symbol{34}abc\symbol{34} + \symbol{34}xyz\symbol{34}}
\\[0.2cm]
yields the string \texttt{\symbol{34}abcxyz\symbol{34}} as a result.
In order to concatenate multiple instances of the same string, we can use the infix
operator ``\texttt{*}''.  For a string $s$ and a natural number $n$, the expression
\\[0.2cm]
\hspace*{1.3cm}
\texttt{$s$ * $n$}
\\[0.2cm]
returns a string that consists of $n$ copies of the string $s$.  For example, the
expression 
\\[0.2cm]
\hspace*{1.3cm}
\texttt{"abc" * 3}
\\[0.2cm]
yields the result
\\[0.2cm]
\hspace*{1.3cm}
\texttt{"abcabcabc"}.
\\[0.2cm]
This also works when the position of the string and the number are exchanged.  Therefore,
\\[0.2cm]
\hspace*{1.3cm}
\texttt{3 * "abc"}
\\[0.2cm]
also yields \texttt{"abcabcabc"}.


In order to extract the $i$-th character of the string $s$, we can use the expression
\\[0.2cm]
\hspace*{1.3cm}
\texttt{$s$[$i$]}.
\\[0.2cm]
As for lists, this also works for negative values of the index $i$.  For example, the expression \texttt{$s$[-1]}
returns the last character of $s$.

There is also a slicing operator.  This operator works similar to lists, for example, if $s$ has the value 
\texttt{\symbol{34}abcdef\symbol{34}}, then 
\\[0.2cm]
\hspace*{1.3cm}
\texttt{s[2..5];}
\\[0.2cm]
yields the result \texttt{\symbol{34}bcde\symbol{34}}, while 
\\[0.2cm]
\hspace*{1.3cm}
\texttt{s[2..];}
\\[0.2cm]
yields \texttt{\symbol{34}bcdef\symbol{34}} and 
\\[0.2cm]
\hspace*{1.3cm}
\texttt{s[..5];}
\\[0.2cm]
gives \texttt{\symbol{34}abcde\symbol{34}}.  In the expressions
\\[0.2cm]
\hspace*{1.3cm}
\texttt{$s$[$a$..$b$]}, \quad \texttt{$s$[$a$..]}, \quad and \quad \texttt{$s$[..$b$]}
\\[0.2cm]
the indices $a$ and $b$ can be negative numbers.  This works in the same way as it works for lists.
For example, if \texttt{s} is a string, then \texttt{s[2..-2]} is the string that results from \texttt{s} by removing the
first and the last character.


\setlx\ provides \href{https://en.wikipedia.org/wiki/String_interpolation}{\emph{string interpolation}}:
If a string contains a substring enclosed in ``\texttt{\symbol{36}}''-symbols, then \setlx\ 
parses this substring as an expression, evaluates this expression, and then substitutes the result
back into the string.  For example, if the variable \texttt{n} has the value $6$, the command
\\[0.2cm]
\hspace*{1.3cm}
\texttt{print(\symbol{34}\symbol{36}n\symbol{36}! = \symbol{36}n!\symbol{36}\symbol{34})};
\\[0.2cm]
will print
\\[0.2cm]
\hspace*{1.3cm}
\texttt{6! = 720}.
\\[0.2cm]
In order to insert a literal ``\texttt{\symbol{36}}''-symbol into a string,  the
``\texttt{\symbol{36}}''-symbol has to be escaped with a backslash.  For example, the command
\\[0.2cm]
\hspace*{1.3cm}
\texttt{print(\symbol{34}A single \symbol{92}\symbol{36}-symbol.\symbol{34});}
\\[0.2cm]
prints the text:
\\[0.2cm]
\hspace*{1.3cm}
\texttt{A single \symbol{36}-symbol.}

\subsection{Literal Strings}
Sometimes it is necessary to turn off any kind of preprocessing when using a string.  This
is achieved by enclosing the content of the string in single quotes.  These strings are
known as \emph{literal} strings.  For example, after
the assignment
\\[0.2cm]
\hspace*{1.3cm}
\texttt{s := '\symbol{92}n';}
\\[0.2cm]
the string \texttt{s} contains exactly two characters:  The first character is the
backslash ``\texttt{\symbol{92}}'', while the second character is the character ``\texttt{n}''.
If, instead, we write
\\[0.2cm]
\hspace*{1.3cm}
\texttt{s := "\symbol{92}n";}
\\[0.2cm]
then the string \texttt{s} contains just one character, which is the newline character.
\textsc{SetlX} supports the same backslash \href{https://en.wikipedia.org/wiki/Escape_sequences_in_C}{escape sequences} 
as the programming language \href{https://en.wikipedia.org/wiki/C_(programming_language)}{\texttt{C}}. 

As we have just seen, there is no replacement of escape sequences in a literal string.
There is no string interpolation either.  Therefore, the statement
\\[0.2cm]
\hspace*{1.3cm}
\texttt{print('\symbol{36}1+2\symbol{36}');}
\\[0.2cm]
prints the string 
\\[0.2cm]
\hspace*{1.3cm}
\texttt{\symbol{36}1+2\symbol{36}}.
\\[0.2cm]
Later, literal strings will come in very handy when dealing with \emph{regular expressions}.
\vspace*{0.2cm}

\noindent
\textbf{Remark}:
It should be noted that \textsc{SetlX} does not have a special data type to support single characters.
Instead, in \textsc{SetlX} single characters are represented as strings of length one. 

\section{Terms}
\setlx\ provides 
\href{http://en.wikipedia.org/wiki/Term_(first-order_logic)#Terms}{\emph{first order terms}}
similar to the terms available in the programming language 
\href{http://en.wikipedia.org/wiki/Prolog}{\emph{Prolog}} \cite{sterling:94}.
Terms are built from \href{https://en.wikipedia.org/wiki/Prolog_syntax_and_semantics}{functors} 
and \emph{arguments}.  To distinguish functors from function
symbols, a functor is prefixed with the operator ``\texttt{@}''.  For example, the expression
\\[0.2cm]
\hspace*{1.3cm}
\texttt{@f(1,\symbol{34}x\symbol{34})}
\\[0.2cm]
is a term with functor \texttt{f} and two arguments.  The functor is just a name, it is 
\underline{not} a function that can be evaluated.  To demonstrate the usefulness of terms, consider
implementing \href{http://en.wikipedia.org/wiki/Binary_search_tree}{\emph{ordered binary trees}} in \setlx. 
There are two types of ordered binary tress:
\begin{enumerate}
\item The empty tree represents the empty set.  We use the functor \texttt{Nil} to represent an
      empty binary tree, so the term
      \\[0.2cm]
      \hspace*{1.3cm}
      $\mathtt{@Nil()}$
      \\[0.2cm]
      codes the empty tree.
\item A non-empty binary tree has three components:
      \begin{enumerate}
      \item The \emph{root} node,
      \item the left subtree, and
      \item the right subtree.
      \end{enumerate}
      The root node stores one element $k$ and all elements in the left subtree $l$ have to be less
      than $k$, while all elements in the right subtree are bigger than $k$.  Therefore, a non-empty
      binary tree can be represented as the term
      \\[0.2cm]
      \hspace*{1.3cm}
      $\texttt{@Node}(k, l, r)$,
      \\[0.2cm]
      where $k$ is the element stored at the root, $l$ is the left subtree and $r$ is the right subtree.
\end{enumerate}
For example, the term
\\[0.2cm]
\hspace*{1.3cm}
\texttt{@Node(2, @Node(1,@Nil(),@Nil()), @Node(3,@Nil(), @Nil()))}
\\[0.2cm]
is a typical binary tree.  At the root, this tree stores the element 2, the left subtree
stores the element 1 and the right subtree stores the element 3.

There are two functions to decompose a term and there is one function that constructs a term.
\begin{enumerate}
\item If $t$ is a term, then the expression
      \\[0.2cm]
      \hspace*{1.3cm}
      $\texttt{fct}(t)$
      \\[0.2cm]
      returns the functor of the term t as a string.  For example, the expression
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{fct(@Node(3,@Nil(),@Nil()))}
      \\[0.2cm]
      yields the result \texttt{\symbol{34}Node\symbol{34}}.
\item If $t$ is a term, then the expression
      \\[0.2cm]
      \hspace*{1.3cm}
      $\mathtt{args}(t)$
      \\[0.2cm]
      returns the list of arguments of the term $t$.  For example, the expression
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{args(@Node(3,@Nil(),@Nil()))}
      \\[0.2cm]
      yields the result 
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{[3, @Nil(), @Nil()]}.
\item The function $\texttt{makeTerm}(f,l)$ constructs a term $t$ such that
      \\[0.2cm]
      \hspace*{1.3cm}
      $\mathtt{fct}(t) = f$  \quad and \quad $\mathtt{args}(t) = l$
      \\[0.2cm]
      holds.  For example,
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{makeTerm(\symbol{34}Node\symbol{34}, 
             [ makeTerm(\symbol{34}Nil\symbol{34},[]), makeTerm(\symbol{34}Nil\symbol{34},[]) ])}
      \\[0.2cm]
      constructs the term
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{@Node(3, @Nil(), @Nil())}.
      \\[0.2cm]
      Note that we must not use the operator ``\texttt{@}'' when using the function \texttt{makeTerm}.
      Of course,  the term \texttt{@Node(3, @Nil(), @Nil())} can also be given directly as an
      expression: The statement 
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{a := @Node(3,@Nil(),@Nil());}
      \\[0.2cm]
      assigns the term \texttt{@Node(3,@Nil(),@Nil())} to the variable \texttt{a}.
\end{enumerate}

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    insert := procedure(m, k1) {
        switch {
            case fct(m) == "Nil" : 
                 return @Node(k1, @Nil(), @Nil());
            case fct(m) == "Node": 
                 [ k2, l, r ] := args(m);
                 if (k1 == k2) {
                     return @Node(k1, l, r);
                 } else if (compare(k1, k2) < 0) { 
                     return @Node(k2, insert(l, k1), r);
                 } else {
                     return @Node(k2, l, insert(r, k1));
                 }
        }
    };
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Inserting an element into a binary tree.}
\label{fig:binary-tree-no-matching.stlx}
\end{figure}

Figure \ref{fig:binary-tree-no-matching.stlx} shows how terms can be used to implement
binary trees.  In this example, we define a function with the name \texttt{insert}.  This function
takes two arguments.  The first argument \texttt{m} is supposed to be a term representing an ordered binary
tree.  The second argument \texttt{k1} denotes the element that is to be inserted into the binary
tree \texttt{m}.   The implementation needs to distinguish two cases:
\begin{enumerate}
\item If the binary tree \texttt{m} is empty, then the function returns the tree
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{@Node(k1, @Nil(), @Nil())}.
      \\[0.2cm]
      This is a binary tree containing the number \texttt{k1} at its root, while both subtrees are
      empty.  In order to check whether \texttt{m} is indeed empty we use the functor of the term
      \texttt{m}.  We test in line  3 whether this functor is \texttt{\symbol{34}Nil\symbol{34}}.
\item If the binary tree \texttt{m} is nonempty, the functor of \texttt{m} is
      \texttt{\symbol{34}Node\symbol{34}}.  In this case, we need to extract the arguments of this
      functor, which is done in line 6: The first argument \texttt{k2} is the element stored at the
      root, while the arguments \texttt{l} and \texttt{r} correspond to the left and the right
      subtree of \texttt{m} respectively.  The predefined function \texttt{compare} is used to
      compare the element \texttt{k1} that is to be inserted into the tree with the element
      \texttt{k2}, which is the element at the root of the tree.

      The expression \texttt{compare(k1, k2)} returns $-1$ if \texttt{k1} is less than
      \texttt{k2}, it returns $+1$ is \texttt{k1} is greater than \texttt{k2}, and it returns $0$
      if \texttt{k1} and \texttt{k2} are the same.  The function \texttt{compare} is implemented for
      all data types.  However, it should be noted that the comparison operators ``\texttt{<}'', ``\texttt{>}'',
      ``\texttt{<=}'', and ``\texttt{>=}'' are only implemented for numbers and sets.
\end{enumerate}
This example uses a number of features of \setlx\ that have not been introduced. The discussion of
the control structure \texttt{switch} will be given in the next chapter.

The present discussion of terms is far from being complete and will be continued in the next chapter when we
discuss matching.

\section{Vectors and Matrices}
\setlx\ has some support for both vectors and matrices.  Suppose we have to solve the following system
of linear equations:
\\[0.2cm]
\hspace*{1.3cm}
$\begin{array}[c]{lcl}
    1 \cdot x + 2 \cdot y + 3 \cdot z & = & 1, \\[0.2cm]
    2 \cdot x + 3 \cdot y + 1 \cdot z & = & 2, \\[0.2cm]
    3 \cdot x + 1 \cdot y + 2 \cdot z & = & 3.          
  \end{array}
$
\\[0.2cm]
In order to solve this system of equations we define the matrix
\\[0.2cm]
\hspace*{1.3cm}
$\mathrm{A} := \left(
  \begin{array}[c]{lll}
    1 & 2 & 3     \\
    2 & 3 & 1     \\
    3 & 1 & 2            
  \end{array}\right)
$ \qquad and the vectors \qquad
$\vec{b} := \left(
  \begin{array}[c]{l}
    1 \\
    2 \\
    3        
  \end{array}\right)
$
\quad and \quad
$\vec{s} := \left(
  \begin{array}[c]{l}
    x \\
    y \\
    z        
  \end{array}\right).
$ 
\\[0.2cm]
Then, the solution $\vec{s}$ can be calculated via the formula
\\[0.2cm]
\hspace*{1.3cm}
$\vec{s} = \mathrm{A}^{-1} \cdot \vec{b}$,
\\[0.2cm]
where $\mathrm{A}^{-1}$ denotes the \href{http://en.wikipedia.org/wiki/Invertible_matrix}{\emph{inverse}} of
the matrix $\mathrm{A}$.  In order to carry out this calculation in 
\setlx, we run the commands shown in Figure \ref{fig:solve-linear.stlx} on page
\pageref{fig:solve-linear.stlx}.  We discuss these statements line by line.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    A := la_matrix([[1, 2, 3], [2, 3, 1], [3, 1, 2]]);
    b := la_vector([1, 2, 3]);
    s := A**-1 * b;
    print(s);
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Solving a system of linear equations using matrix inversion.}
\label{fig:solve-linear.stlx}
\end{figure}


\begin{enumerate}
\item Line 1 defines the matrix $\mathrm{A}$ using the predefined function \texttt{la\_matrix}.
      Note that the matrix $\mathrm{A}$ is defined as a list of its rows, where each row is
      represented as a list of numbers.
\item Line 2 defines the vector $\vec{b}$ using the predefined function \texttt{la\_vector}.
\item In line 3, the expression \texttt{A**-1} computes the inverse of the matrix $A$.
      This inverse is then multiplied with the vector $\vec{b}$ to yield the solution $\vec{s}$.
\item In line 4, printing the variable \texttt{s} yields the following result:
      \\[0.2cm]
      \hspace*{-0.8cm}
      \texttt{< 0.9999999999999998 >  < 1.1102230246251565E-16 >  < 5.551115123125783E-17 >}
      \\[0.2cm]
      This shows that the solution to the system of equations that was given initially is approximately
      \\[0.2cm]
      \hspace*{1.3cm}
      $x \approx 1$, \quad $y \approx 0$, \quad and \quad $z \approx 0$.  
\end{enumerate}
Instead of computing the inverse of the matrix $a$ we could have solved the system of equations
using the command \texttt{la\_solve} as follows:
\\[0.2cm]
\hspace*{1.3cm}
\texttt{s := la\_solve(A, b);}
\\[0.2cm]
In that case, \setlx\ computes the solution
\\[0.2cm]
\hspace*{1.3cm}
\texttt{< 1.0 >  < 0.0 >  < 0.0 >}.
\\[0.2cm]
The solution computed by \texttt{la\_solve} is more precise than the solution computed using the
inverse matrix.  Presumable the method
\href{http://math.nist.gov/javanumerics/jama/doc/Jama/Matrix.html#solve(Jama.Matrix)}{\texttt{solve}}
from the \href{http://math.nist.gov/javanumerics/jama}{\textsc{Jama}} library that is working behind the
scenes of the function \texttt{la\_solve} is using a final iteration step to increase the precision
of the result.
\vspace*{0.2cm}

\noindent
Chapter \ref{chapter:linear-algebra.tex} discusses the data types of vectors and matrices in more
detail. 



%%% local Variables: 
%%% mode: latex
%%% TeX-master: "tutorial.tex"
%%% End: 

