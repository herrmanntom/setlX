class globals() {
    static {
        properties := { 'count', 'color', 'shape', 'filler' };
        cardCounts := { 'one', 'two', 'three' };
        cardColors := { 'red', 'green', 'purple' };
        cardShapes := { 'diamond', 'round', 's' };
        cardFiller := { 'full', 'striped', 'empty' };
    }
}

newCard := procedure(count, color, shape, filler) {
    if (count in globals.cardCounts) {
        if (color in globals.cardColors) {
            if (shape in globals.cardShapes) {
                if (filler in globals.cardFiller) {
                    return {['count', count], ['color', color], ['shape', shape], ['filler', filler]};
                } else {
                    throw("unknown filler: " + filler);
                }
            } else {
                throw("unknown shape: " + shape);
            }
        } else {
            throw("unknown color: " + color);
        }
    } else {
        throw("unknown filler: " + filler);
    }
};

getAllCardSets := procedure(cardStack) {
    // this is the formal version
    // { {cardA, cardB, cardC}: cardA in cardStack, cardB in cardStack, cardC in cardStack | #{cardA, cardB, cardC} == 3 && isCardSet(cardA, cardB, cardC) };
    // which was optimized a little bit to remove duplicated tests
    allSets := {};
    cardsAToTest := cardStack;
    while(#cardsAToTest > 2) {
        cardA := from(cardsAToTest);
        cardsBToTest := cardsAToTest;
        while (#cardsBToTest > 1) {
            cardB := from(cardsBToTest);
            cardsCToTest := cardsBToTest;
            while (#cardsCToTest > 0) {
                cardC := from(cardsCToTest);
                if (isCardSet(cardA, cardB, cardC)) {
                    allSets += { {cardA, cardB, cardC} };
                }
            }
        }
    }
    return allSets;
};

getFirstCardSet := procedure(cardStack) {
    // this is the formal version
    //  if (exists(cardA in cardStack, cardB in cardStack, cardC in cardStack | #{cardA, cardB, cardC} == 3 && isCardSet(cardA, cardB, cardC))) {
    //      return {cardA, cardB, cardC};
    //  }
    //  return om;
    // which was optimized a little bit to remove duplicated tests
    cardsAToTest := cardStack;
    while(#cardsAToTest > 2) {
        cardA := from(cardsAToTest);
        cardsBToTest := cardsAToTest;
        while (#cardsBToTest > 1) {
            cardB := from(cardsBToTest);
            cardsCToTest := cardsBToTest;
            while (#cardsCToTest > 0) {
                cardC := from(cardsCToTest);
                if (isCardSet(cardA, cardB, cardC)) {
                   return {cardA, cardB, cardC};
                }
            }
        }
    }
    return om;
};

getCardStackCombinationWithoutSet := procedure(cardStack, selectedCards, numberOfCardsToFormSubStack) {
    minCount := numberOfCardsToFormSubStack - 1 - #selectedCards;
    while (#cardStack > minCount) {
        testCards := selectedCards + { from(cardStack) };

        if (#testCards < 3 || getFirstCardSet(testCards) == om) {
            if (#testCards == numberOfCardsToFormSubStack) {
                return testCards;
            } else {
                result := getCardStackCombinationWithoutSet(cardStack, testCards, numberOfCardsToFormSubStack);
                if (result != om) {
                    return result;
                }
            }
        }
    }
    return om;
};

isCardSet := procedure(cardA, cardB, cardC) {
    return forall(
                    property in globals.properties
                |
                    (cardA[property] == cardB[property] && cardB[property] == cardC[property])
                    ||
                    (cardA[property] != cardB[property] && cardB[property] != cardC[property] && cardC[property] != cardA[property])
           );
};

printCard := procedure(card) {
    for (property in globals.properties) {
        nPrint("\t", card[property]);
    }
    print();
};

printCards := procedure(cards) {
    if (cards != om) {
        for (card in cards) {
            printCard(card);
        }
    }
};

/*output*/

print("Each card has 4 properties and each property has 3 possible values:");
print("\tsymbol count:\t", globals.cardCounts);
print("\tsymbol color:\t", globals.cardColors);
print("\tsymbol shape:\t", globals.cardShapes);
print("\tsymbol filler:\t", globals.cardFiller);
print();

nPrint("With all combinations, the game contains ");
allCards := { newCard(count, color, shape, filler): count in globals.cardCounts, color in globals.cardColors, shape in globals.cardShapes, filler in globals.cardFiller };
print(#allCards + " cards.");
print();

print("Goal of the game is to find sets of 3 cards.");
print();

print("To form a card set, each property must either be the same on all card, or different on all cards, like this one:");
printCards(getFirstCardSet(allCards));
print();

nPrint("When concidering all cards, there are ");
allSets := getAllCardSets(allCards);
print(#allSets + " possible sets of 3 cards.");
print();

print("During a normal game, there are just 12 cards on the table. Not all possible combinations of 12 cards contain a set. For example those:");
nonSetCombination := getCardStackCombinationWithoutSet(allCards, {}, 12);
if (isSet(nonSetCombination)) {
    printCards(nonSetCombination);
} else {
    print("... or not!?!?!");
}
print();

print("In case the 12 cards do not contain a set, 3 more cards are put on the table. But also not all possible combinations of 15 cards contain a set. For example those:");
nonSetCombination := getCardStackCombinationWithoutSet(allCards, {}, 15);
if (nonSetCombination != om) {
    printCards(nonSetCombination);
} else {
    print("... or not!?!?!");
}
print();

print("Then again 3 more cards are put on the table. Again not all possible combinations of 18 cards contain a set. For example those:");
nonSetCombination := getCardStackCombinationWithoutSet(allCards, {}, 18);
if (nonSetCombination != om) {
    printCards(nonSetCombination);
} else {
    print("... or not!?!?!");
}
print();

print("Then again 3 more cards are put on the table, raising the number of cards to 21. This ensures a set can be found. Maximum number of set free cards is 20. For example those:");
nonSetCombination := getCardStackCombinationWithoutSet(allCards, {}, 20);
if (nonSetCombination != om) {
    printCards(nonSetCombination);
} else {
    print("... or not!?!?!");
}
print();

/* if you wonder... it takes way too long to run getCardStackCombinationWithoutSet(allCards, {}, 21) to "confirm" it will return om */

