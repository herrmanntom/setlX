
problem := procedure(s) {
	return ("Ziege" in s && "Kohl" in s) || ("Wolf" in s && "Ziege" in s);
};

reachable := procedure(x, y, r) {
	p := {[x]};
	while (true) {
		old_P := p;
		p := p + path_product(p, r);
		found := {p in p | p(#p) == y};
		if (found != {}) {
			return arb(found);
		}
		if (p == old_P) {
			return;
		}
	}
};

path_product := procedure(p, q) {
	return {add(p, q): p in p, q in q | p(#p) == q(1) && ( ! (cyclic(add(p, q))) )};
};

cyclic := procedure(p) {
	return #{x: x in p} < #p;
};

add := procedure(p, q) {
	return p + q(2..);
};

all := {"Bauer", "Wolf", "Ziege", "Kohl"};
p := {[s1, all - s1]: s1 in pow(all)};
r1 := {[[s1, s2], [s1 - b, s2 + b]]: [s1, s2] in p, b in pow(s1) | "Bauer" in b && #b <= 2 && ( ! (problem(s1 - b)) )};
r2 := {[[s1, s2], [s1 + b, s2 - b]]: [s1, s2] in p, b in pow(s2) | "Bauer" in b && #b <= 2 && ( ! (problem(s2 - b)) )};
r := r1 + r2;
start := [all, {}];
goal := [{}, all];
path := reachable(start, goal, r);
for (i in [1 .. #path]) {
	s1 := path(i)(1);
	s2 := path(i)(2);
	print(s1, 65 * " ", s2);
	if (i == #path) {
		break;
	}
	if ("Bauer" in s1) {
		m := s1 - path(i + 1)(1);
		print("                                     >>>> ", m, " >>>> ");
	} else {
		m := s2 - path(i + 1)(2);
		print("                                     <<<< ", m, " <<<< ");
	}
}

